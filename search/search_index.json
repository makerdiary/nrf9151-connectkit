{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What's new","text":"<ul> <li> <p>Introducing nRF Cloud</p> <p>nRF Cloud offers a suite of services optimized for Nordic ultra-low power wireless devices that supports your IoT deployment throughout its entire lifecycle.</p> <p> Mar 11, 2025 \u30fb  4 min read</p> </li> <li> <p></p> <p>Introducing Interface MCU</p> <p>The Interface MCU simplifies debugging and programming of the nRF9151 SiP without external tools and provides access to board-specific features.</p> <p> Mar 10, 2025 \u30fb  3 min read</p> </li> <li> <p></p> <p>nRF9151 Connect Kit is Here!</p> <p>Today we are excited to launch our latest IoT prototyping kit, the nRF9151 Connect Kit, for LTE-M, NB-IoT, DECT NR+, and GNSS applications.</p> <p> Mar 7, 2025 \u30fb  4 min read</p> </li> </ul> <p>View all</p>"},{"location":"LICENSE/","title":"License","text":"<p>This project is licensed under the Apache License 2.0 unless otherwise stated. The nRF Connect SDK and its components are licensed under the 5-Clause Nordic License.</p> <p>This project may include some imported or reused components that are licensed under different terms. Please refer to the license files within those components for details.</p> Apache License 2.05-Clause Nordic License <pre><code>                                Apache License\n                          Version 2.0, January 2004\n                       http://www.apache.org/licenses/\n\n  TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n  1. Definitions.\n\n     \"License\" shall mean the terms and conditions for use, reproduction,\n     and distribution as defined by Sections 1 through 9 of this document.\n\n     \"Licensor\" shall mean the copyright owner or entity authorized by\n     the copyright owner that is granting the License.\n\n     \"Legal Entity\" shall mean the union of the acting entity and all\n     other entities that control, are controlled by, or are under common\n     control with that entity. For the purposes of this definition,\n     \"control\" means (i) the power, direct or indirect, to cause the\n     direction or management of such entity, whether by contract or\n     otherwise, or (ii) ownership of fifty percent (50%) or more of the\n     outstanding shares, or (iii) beneficial ownership of such entity.\n\n     \"You\" (or \"Your\") shall mean an individual or Legal Entity\n     exercising permissions granted by this License.\n\n     \"Source\" form shall mean the preferred form for making modifications,\n     including but not limited to software source code, documentation\n     source, and configuration files.\n\n     \"Object\" form shall mean any form resulting from mechanical\n     transformation or translation of a Source form, including but\n     not limited to compiled object code, generated documentation,\n     and conversions to other media types.\n\n     \"Work\" shall mean the work of authorship, whether in Source or\n     Object form, made available under the License, as indicated by a\n     copyright notice that is included in or attached to the work\n     (an example is provided in the Appendix below).\n\n     \"Derivative Works\" shall mean any work, whether in Source or Object\n     form, that is based on (or derived from) the Work and for which the\n     editorial revisions, annotations, elaborations, or other modifications\n     represent, as a whole, an original work of authorship. For the purposes\n     of this License, Derivative Works shall not include works that remain\n     separable from, or merely link (or bind by name) to the interfaces of,\n     the Work and Derivative Works thereof.\n\n     \"Contribution\" shall mean any work of authorship, including\n     the original version of the Work and any modifications or additions\n     to that Work or Derivative Works thereof, that is intentionally\n     submitted to Licensor for inclusion in the Work by the copyright owner\n     or by an individual or Legal Entity authorized to submit on behalf of\n     the copyright owner. For the purposes of this definition, \"submitted\"\n     means any form of electronic, verbal, or written communication sent\n     to the Licensor or its representatives, including but not limited to\n     communication on electronic mailing lists, source code control systems,\n     and issue tracking systems that are managed by, or on behalf of, the\n     Licensor for the purpose of discussing and improving the Work, but\n     excluding communication that is conspicuously marked or otherwise\n     designated in writing by the copyright owner as \"Not a Contribution.\"\n\n     \"Contributor\" shall mean Licensor and any individual or Legal Entity\n     on behalf of whom a Contribution has been received by Licensor and\n     subsequently incorporated within the Work.\n\n  2. Grant of Copyright License. Subject to the terms and conditions of\n     this License, each Contributor hereby grants to You a perpetual,\n     worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n     copyright license to reproduce, prepare Derivative Works of,\n     publicly display, publicly perform, sublicense, and distribute the\n     Work and such Derivative Works in Source or Object form.\n\n  3. Grant of Patent License. Subject to the terms and conditions of\n     this License, each Contributor hereby grants to You a perpetual,\n     worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n     (except as stated in this section) patent license to make, have made,\n     use, offer to sell, sell, import, and otherwise transfer the Work,\n     where such license applies only to those patent claims licensable\n     by such Contributor that are necessarily infringed by their\n     Contribution(s) alone or by combination of their Contribution(s)\n     with the Work to which such Contribution(s) was submitted. If You\n     institute patent litigation against any entity (including a\n     cross-claim or counterclaim in a lawsuit) alleging that the Work\n     or a Contribution incorporated within the Work constitutes direct\n     or contributory patent infringement, then any patent licenses\n     granted to You under this License for that Work shall terminate\n     as of the date such litigation is filed.\n\n  4. Redistribution. You may reproduce and distribute copies of the\n     Work or Derivative Works thereof in any medium, with or without\n     modifications, and in Source or Object form, provided that You\n     meet the following conditions:\n\n     (a) You must give any other recipients of the Work or\n        Derivative Works a copy of this License; and\n\n     (b) You must cause any modified files to carry prominent notices\n        stating that You changed the files; and\n\n     (c) You must retain, in the Source form of any Derivative Works\n        that You distribute, all copyright, patent, trademark, and\n        attribution notices from the Source form of the Work,\n        excluding those notices that do not pertain to any part of\n        the Derivative Works; and\n\n     (d) If the Work includes a \"NOTICE\" text file as part of its\n        distribution, then any Derivative Works that You distribute must\n        include a readable copy of the attribution notices contained\n        within such NOTICE file, excluding those notices that do not\n        pertain to any part of the Derivative Works, in at least one\n        of the following places: within a NOTICE text file distributed\n        as part of the Derivative Works; within the Source form or\n        documentation, if provided along with the Derivative Works; or,\n        within a display generated by the Derivative Works, if and\n        wherever such third-party notices normally appear. The contents\n        of the NOTICE file are for informational purposes only and\n        do not modify the License. You may add Your own attribution\n        notices within Derivative Works that You distribute, alongside\n        or as an addendum to the NOTICE text from the Work, provided\n        that such additional attribution notices cannot be construed\n        as modifying the License.\n\n     You may add Your own copyright statement to Your modifications and\n     may provide additional or different license terms and conditions\n     for use, reproduction, or distribution of Your modifications, or\n     for any such Derivative Works as a whole, provided Your use,\n     reproduction, and distribution of the Work otherwise complies with\n     the conditions stated in this License.\n\n  5. Submission of Contributions. Unless You explicitly state otherwise,\n     any Contribution intentionally submitted for inclusion in the Work\n     by You to the Licensor shall be under the terms and conditions of\n     this License, without any additional terms or conditions.\n     Notwithstanding the above, nothing herein shall supersede or modify\n     the terms of any separate license agreement you may have executed\n     with Licensor regarding such Contributions.\n\n  6. Trademarks. This License does not grant permission to use the trade\n     names, trademarks, service marks, or product names of the Licensor,\n     except as required for reasonable and customary use in describing the\n     origin of the Work and reproducing the content of the NOTICE file.\n\n  7. Disclaimer of Warranty. Unless required by applicable law or\n     agreed to in writing, Licensor provides the Work (and each\n     Contributor provides its Contributions) on an \"AS IS\" BASIS,\n     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n     implied, including, without limitation, any warranties or conditions\n     of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n     PARTICULAR PURPOSE. You are solely responsible for determining the\n     appropriateness of using or redistributing the Work and assume any\n     risks associated with Your exercise of permissions under this License.\n\n  8. Limitation of Liability. In no event and under no legal theory,\n     whether in tort (including negligence), contract, or otherwise,\n     unless required by applicable law (such as deliberate and grossly\n     negligent acts) or agreed to in writing, shall any Contributor be\n     liable to You for damages, including any direct, indirect, special,\n     incidental, or consequential damages of any character arising as a\n     result of this License or out of the use or inability to use the\n     Work (including but not limited to damages for loss of goodwill,\n     work stoppage, computer failure or malfunction, or any and all\n     other commercial damages or losses), even if such Contributor\n     has been advised of the possibility of such damages.\n\n  9. Accepting Warranty or Additional Liability. While redistributing\n     the Work or Derivative Works thereof, You may choose to offer,\n     and charge a fee for, acceptance of support, warranty, indemnity,\n     or other liability obligations and/or rights consistent with this\n     License. However, in accepting such obligations, You may act only\n     on Your own behalf and on Your sole responsibility, not on behalf\n     of any other Contributor, and only if You agree to indemnify,\n     defend, and hold each Contributor harmless for any liability\n     incurred by, or claims asserted against, such Contributor by reason\n     of your accepting any such warranty or additional liability.\n\n  END OF TERMS AND CONDITIONS\n\n  APPENDIX: How to apply the Apache License to your work.\n\n     To apply the Apache License to your work, attach the following\n     boilerplate notice, with the fields enclosed by brackets \"{}\"\n     replaced with your own identifying information. (Don't include\n     the brackets!)  The text should be enclosed in the appropriate\n     comment syntax for the file format. We also recommend that a\n     file or class name and description of purpose be included on the\n     same \"printed page\" as the copyright notice for easier\n     identification within third-party archives.\n\n  Copyright {yyyy} {name of copyright owner}\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n</code></pre> <pre><code>  LicenseID:  LicenseRef-Nordic-5-Clause\n\n  ExtractedText: &lt;text&gt;\n  Copyright (c) 2018, Nordic Semiconductor ASA\n\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without modification,\n  are permitted provided that the following conditions are met:\n\n  1. Redistributions of source code must retain the above copyright notice, this\n     list of conditions and the following disclaimer.\n\n  2. Redistributions in binary form, except as embedded into a Nordic\n     Semiconductor ASA integrated circuit in a product or a software update for\n     such product, must reproduce the above copyright notice, this list of\n     conditions and the following disclaimer in the documentation and/or other\n     materials provided with the distribution.\n\n  3. Neither the name of Nordic Semiconductor ASA nor the names of its\n     contributors may be used to endorse or promote products derived from this\n     software without specific prior written permission.\n\n  4. This software, with or without modification, must only be used with a\n     Nordic Semiconductor ASA integrated circuit.\n\n  5. Any software provided in binary form under this license must not be reverse\n     engineered, decompiled, modified and/or disassembled.\n\n  THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA \"AS IS\" AND ANY EXPRESS\n  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n  OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  &lt;/text&gt;\n</code></pre>"},{"location":"getting-started/","title":"nRF9151 Connect Kit Quick Start Guide","text":""},{"location":"getting-started/#introduction","title":"Introduction","text":"<p>This quick start guide will navigate you through the process of starting up your new nRF9151 Connect Kit. The board comes pre-programmed with the Modem Shell application, enabling you to explore its various features right out of the box.</p>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x U.FL cabled GNSS Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"getting-started/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Attach the U.FL cabled GNSS Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"getting-started/#connect-to-the-modem-shell","title":"Connect to the Modem Shell","text":"<p>Once the board is connected, it exposes two COM ports, the first one is connected to the Modem Shell whose terminal prompt appears as <code>mosh:~$</code>.</p> <p>Open up a serial terminal, specifying the Modem Shell COM port:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Press the DFU/RST button to reset the nRF9151 SiP. Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\nTF-M isolation level is: 0x00000001\nTF-M Float ABI: Hard\nLazy stacking enabled\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\n\nReset reason: PIN reset\nmosh:~$\nMOSH version:       v2.9.99-98a5e50b9ac1\nMOSH build id:      custom\nMOSH build variant: dev\nHW version:         nRF9151 LACA A0A\nModem FW version:   mfw_nrf91x1_2.0.2\nModem FW UUID:      320176d5-9f40-45fc-923b-2661ec18d547\n\n\nModem domain event: Light search done\nmosh:~$\n</code></pre> <p>Type Tab to list all supported commands. When you type a command with <code>--help</code>, the terminal shows its usage, for example <code>ping --help</code>:</p> Terminal<pre><code>mosh:~$\n  at           clear        cloud_rest   curl         date         device       dl           fota         gnss\n  gpio_count   heap         help         history      iperf3       kernel       link         location     ping\n  print        rem          resize       rest         retval       shell        sleep        sms          sock\n  startup_cmd  th           uart         version\nmosh:~$ ping --help\nUsage: ping [options] -d destination\n\n  -d, --destination, [str] Name or IP address\nOptions:\n  -t, --timeout, [int]     Ping timeout in milliseconds\n  -c, --count, [int]       The number of times to send the ping request\n  -i, --interval, [int]    Interval between successive packet transmissions\n                           in milliseconds\n  -l, --length, [int]      Payload length to be sent\n  -I, --cid, [int]         Use this option to bind pinging to specific CID.\n                           See link cmd for interfaces\n  -6, --ipv6,              Force IPv6 usage with the dual stack interfaces\n  -r, --rai                Set RAI options for ping socket. In order to use RAI,\n                           it must be enabled with 'link rai' command.\n  -h, --help,              Shows this help information\n</code></pre>"},{"location":"getting-started/#connect-to-the-lte-network","title":"Connect to the LTE network","text":"<p>The Modem Shell application will automatically connect to the LTE network. Wait for the LTE link to be established. You can also type <code>link status</code> to show status of the current connection:</p> Terminal<pre><code>mosh:~$ link status\nModem functional mode: normal\nNetwork registration status: Connected - home network\nModem config for system mode: LTE-M - NB-IoT - GNSS\nModem config for LTE preference: LTE-M is preferred, but PLMN selection is more important\nCurrently active system mode: NB-IoT\nBattery voltage:       4516 mV\nModem temperature:     25 C\nDevice ID:             nrf-359404230074347\nOperator full name:   \"\"\nOperator short name:  \"\"\nOperator PLMN:        \"46000\"\nCurrent cell id:       213818780 (0x0CBE9D9C)\nCurrent phy cell id:   352\nCurrent band:          8\nCurrent TAC:           7464 (0x1D28)\nCurrent rsrp:          55: -86dBm\nCurrent snr:           26: 2dB\nMobile network time and date: 25/02/16,05:25:35+32\nPDP context info 1:\n  CID:                0\n  PDN ID:             0\n  PDP context active: yes\n  PDP type:           IP\n  APN:                cmnbiot\n  IPv4 MTU:           1280\n  IPv4 address:       100.25.164.39\n  IPv6 address:       ::\n  IPv4 DNS address:   120.196.165.7, 221.179.38.7\n  IPv6 DNS address:   ::, ::\n</code></pre> <p>Use <code>ping</code> command to test the reachability of a host on an IP network. For example:</p> <pre><code>ping -d makerdiary.com  # (1)!\n</code></pre> <ol> <li> Terminal<pre><code>mosh:~$ ping -d makerdiary.com\nInitiating ping to: makerdiary.com\nModem domain event: CE-level 0\nRRC mode: Connected\nSource IP addr: 100.19.132.199\nDestination IP addr: 23.227.38.32\nPinging makerdiary.com results: time=0.316secs, payload sent: 0, payload received 0\nPinging makerdiary.com results: time=0.927secs, payload sent: 0, payload received 0\nPinging makerdiary.com results: time=0.912secs, payload sent: 0, payload received 0\nPinging makerdiary.com results: time=0.907secs, payload sent: 0, payload received 0\nPing statistics for makerdiary.com:\n    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss)\nApproximate round trip times in milli-seconds:\n    Minimum = 316ms, Maximum = 927ms, Average = 765ms\nPinging DONE\n</code></pre> </li> </ol>"},{"location":"getting-started/#explore-the-gnss-functionality","title":"Explore the GNSS functionality","text":"<p>The Modem Shell application provides commands to explore the GNSS functionality.</p> <p>Use <code>gnss</code> command to start the GNSS:</p> <pre><code>gnss start\n</code></pre> <p>For best results retrieving GNSS data, place the board outside with a clear view of the sky. Observe that the following information is displayed upon acquiring a fix:</p> Terminal<pre><code>Fix valid:          true\nLeap second valid:  false\nSleep between PVT:  false\nDeadline missed:    false\nInsuf. time window: false\nVelocity valid:     true\nScheduled download: false\nExecution time:     52587 ms\nTime:              22.02.2025 07:29:24.141\nLatitude:          22.694009\nLongitude:         113.941902\nAccuracy:          3.5 m\nAltitude:          103.4 m\nAltitude accuracy: 5.5 m\nSpeed:             0.1 m/s\nSpeed accuracy:    0.6 m/s\nV. speed:          0.2 m/s\nV. speed accuracy: 0.6 m/s\nHeading:           0.0 deg\nHeading accuracy:  180.0 deg\nPDOP:              4.6\nHDOP:              2.6\nVDOP:              3.7\nTDOP:              3.4\nGoogle maps URL:   https://maps.google.com/?q=22.694009,113.941902\nSV:  22 C/N0: 38.7 el: 42 az: 331 signal: 1 in fix: 1 unhealthy: 0\nSV:  17 C/N0: 37.7 el: 43 az: 325 signal: 1 in fix: 1 unhealthy: 0\nSV:  14 C/N0: 39.7 el: 63 az: 342 signal: 1 in fix: 1 unhealthy: 0\nSV: 195 C/N0: 40.2 el: 63 az:  55 signal: 3 in fix: 1 unhealthy: 0\nSV: 194 C/N0: 38.9 el: 61 az:  92 signal: 3 in fix: 1 unhealthy: 0\nSV:   1 C/N0: 40.1 el: 37 az:  35 signal: 1 in fix: 1 unhealthy: 0\nSV:   3 C/N0: 32.6 el: 40 az:  97 signal: 1 in fix: 1 unhealthy: 0\nSV: 199 C/N0: 31.3 el:  0 az:   0 signal: 3 in fix: 0 unhealthy: 0\nSV:  19 C/N0: 24.5 el:  0 az:   0 signal: 1 in fix: 0 unhealthy: 0\n...\n</code></pre> <p>To turn off the GNSS, run the following command:</p> <pre><code>gnss stop\n</code></pre> <p>Optimize GNSS reception</p> <ul> <li>GNSS signals do not usually penetrate ceilings or other structures that well. For best GNSS performance, the antenna should be placed outside on a flat surface in an open space far from sources of interference and other structures that can block the satellite signals.</li> <li>The GNSS patch antenna achieves the highest gain when placed horizontally on a surface (x-y) facing the z-axis since it can receive all propagated GNSS signals. A lower gain is experienced if the patch antenna is mounted at an angle.</li> </ul>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<p>Congratulations! You've completed the quick start guide and explored some features of the Out-of-Box application. There is much more to explore. Check out our developer guides:</p> <ul> <li> <p>Develop with nRF Connect SDK</p> </li> <li> <p>Programming Guide</p> </li> </ul>"},{"location":"hardware/","title":"Hardware description","text":"<p>This section of the documentation specifies and describes the nRF9151 Connect Kit mainly from a hardware point of view.</p>"},{"location":"hardware/#hardware-diagram","title":"Hardware diagram","text":"<p>The following figure illustrates the nRF9151 Connect Kit hardware diagram. The design has loose or pre-soldered pin headers available.</p> <p></p> <p></p>"},{"location":"hardware/#mechanical-dimensions","title":"Mechanical dimensions","text":"<p>nRF9151 Connect Kit is a 4-layer chem. Gold, 55.88mm x 20.32mm (2.2\" x 0.8\") 1mm thick PCB with a USB Type-C port, a battery connector, a nano-SIM card slot and 40x castellated/through-hole pins.</p> <p> Download DXF Files</p> <p></p>"},{"location":"hardware/#power-supply","title":"Power supply","text":"<p>nRF9151 Connect Kit can be powered through the USB-C port, a Li-Ion/LiPo/LiFePO4 battery, or by an external power source. The board contains a BQ25180 I2C programmable battery charger with power path management and ultra low quiescent current, and a TPS63901 buck-boost converter with 75-nA quiescent current and 1.8V/3.3V configurable power supply for I/Os.</p> <p>The following figure describes the power supply architecture:</p> <p></p> <p>Applying an external power source at VBUS</p> <p>If the USB-C port is not going to be used, it is safe to apply an external power source at VBUS. However, if the USB-C port is in use, the VBUS pin should NOT be powered by any external power source. Otherwise it may damage the USB port or the external power source. </p>"},{"location":"hardware/#interface-mcu","title":"Interface MCU","text":"<p>nRF9151 Connect Kit features an on-board Interface MCU built using the nRF52820, which has CMSIS-DAP support to enable programming, debug as well as modem firmware update without using any external tools. The Interface MCU also includes a USB-UART bridge for log, trace and terminal emulation, and an Interface Shell bundled with helpful commands to access the board-specific functionality.</p> <p>The following figure describes the functional architecture of the Interface MCU:</p> <p></p> <p>The following table describes the pin functions of the Interface MCU:</p> Pin name Description P0.0 GPIO pin used for SWCLK output. Connect to the SWCLK pin of nRF9151 SiP. P0.1 GPIO pin used for SWDIO input/output. Connect to the SWDIO pin of nRF9151 SiP. P0.2 SDA pin of the I2C bus. Connect to the SDA pin of BQ25180 through a 10-k\u03a9 pullup resistor. P0.3 SCL pin of the I2C bus. Connect to the SCL pin of BQ25180 through a 10-k\u03a9 pullup resistor. P0.4/RX RXD pin of the UART bridge. Connect to the P0.11 pin of nRF9151 SiP. P0.5/TX TXD pin of the UART bridge. Connect to the P0.12 pin of nRF9151 SiP. P0.7 GPIO pin used for RESET output. Connect to the RESET pin of nRF9151 SiP. P0.8 GPIO pin used to select the voltage of VDD_GPIO. Connect to the SEL pin of TPS63901 through a 1-M\u03a9 pulldown resistor. Selects 1.8V when a high level is applied to this pin. Selects 3.3V when a low level is applied to this pin. P0.14 GPIO pin used to control the Blue LED of RGB LED driven by a MOS switch. A high level applied to this pin turns on the LED and a low level turns it off. P0.15 GPIO pin used to control the Green LED of RGB LED driven by a MOS switch. A high level applied to this pin turns on the LED and a low level turns it off. P0.16 GPIO pin used to control the Green LED driven by a MOS switch. A high level applied to this pin turns on the LED and a low level turns it off. P0.17 GPIO pin used to control the TS/MR pin of BQ25180. TS/MR is driven by a MOS switch and pulls to GND when A high level applied to this pin. P0.20 GPIO pin used to control the Red LED of RGB LED driven by a MOS switch. A high level applied to this pin turns on the LED and a low level turns it off. P0.28 GPIO pin connected to the /INT pin of BQ25180. When a fault occurs, a 128-\u03bcs active low pulse is sent out to this pin as an interrupt. P0.29 GPIO pin used to detect the nano-SIM card inserting. This pin pulls to GND when no card is inserted. P0.30 GPIO pin used to detect button press of the DFU/RST button. This pin pulls to GND when the button is pressed."},{"location":"hardware/#general-purpose-ios","title":"General purpose I/Os","text":"<p>There are up to 31 multi-function General Purpose I/Os (8 can be configured as ADC inputs) available on the header pins. These GPIOs are powered from the VDD_GPIO rail which is 1.8V or 3.3V configurable. Any GPIO can be mapped to a digital peripheral (such as SPI, UART, TWI, PDM, I2S and PWM) for layout flexibility.</p> <p>The following figure illustrates the GPIOs pinout:</p> <p></p>"},{"location":"hardware/#buttons","title":"Buttons","text":"<p>nRF9151 Connect Kit has two on-board push-buttons, one labeled with USR/P25 is connected to the <code>P0.25</code> of nRF9151 SiP, the other labeled with DFU/RST is connected to the <code>P0.30</code> of the Interface MCU (nRF52820).</p> <p>The following table describes the function of the buttons:</p> Button GPIO Description USR/P25 P0.25  nRF9151 User programmable push-button controlled by nRF9151. The P0.25 pin pulls to GND when the button is pressed DFU/RST P0.30  nRF52820 This push-button is controlled by nRF52820 and its behavior depends on the Interface MCU firmware.  The P0.30 pin pulls to GND when the button is pressed.  Push and hold this button and then power up the board, the board will run into the Interface MCU UF2 Bootloader Mode.  In Interface MCU Normal Mode, pushing this button resets the nRF9151 SiP."},{"location":"hardware/#leds","title":"LEDs","text":"<p>nRF9151 Connect Kit has one Green LED and one RGB LED that are controlled by dedicated GPIOs of the Interface MCU (nRF52820). Each LED is driven by a MOS switch and powered from the VSYS rail. A high level applied to the GPIO pin turns on the LED and a low level turns it off.</p> <p>The following figure shows the connection and behavior of each LED:</p> LED GPIO Description Green LED P0.16  nRF52820 Indicates the VBUS power state. Stays on (solid) when the power is good. RGB LED - Red P0.20  nRF52820 In Interface MCU UF2 Bootloader Mode, this LED blinks fast when updating the firmware, and breathes slow when in idle state. In Interface MCU Normal Mode, it blinks fast when any UART bridge transmission is enabled, and stays off when in idle state. RGB LED - Green P0.15  nRF52820 Indicates the battery charging status. Breathes slow when the battery is charging. Stays off when charging is complete or when charging is disabled.  If no battery is connected, the indication will switch between charging status and charging done status. RGB LED - Blue P0.14  nRF52820 Indicates the DAP transmission state. It blinks fast when any DAP transmission is enabled, and stays off when in idle state."},{"location":"hardware/#sim-and-esim","title":"SIM and eSIM","text":"<p>nRF9151 Connect Kit supports a SIM card. It has a pluggable SIM card socket that is compatible with a nano-sized SIM (4FF). The board also has an unpopulated eSIM (MFF2) footprint that can be populated with a compatible eSIM IC.</p> <p>The following figure illustrates the nano-SIM socket and eSIM footprint:</p> <p></p> <p>Only one SIM is supported</p> <p>Using the nano-SIM socket is the default. If an eSIM is soldered onto the board, the nano-SIM socket should be left unused.</p>"},{"location":"hardware/#ltedect-nr-rf-interface","title":"LTE/DECT NR+ RF interface","text":"<p>nRF9151 Connect Kit has a U.FL receptacle for the external LTE-M/NB-IoT/NR+ antenna. Included with the kit is a U.FL cabled LTE-M/NB-IoT/NR+ flexible antenna. The antenna is optimized for global operation, supporting all LTE frequency bands in the region of 698 MHz to 960 MHz and 1710 MHz to 2200 MHz.</p> <p>The following figure shows how to attach the LTE-M/NB-IoT/NR+ flexible antenna:</p> <p></p>"},{"location":"hardware/#gnss-rf-interface","title":"GNSS RF interface","text":"<p>nRF9151 Connect Kit has a U.FL receptacle for the external GNSS antenna. Included with the kit is a U.FL cabled GNSS antenna. The signal from the GNSS antenna is amplified by a Low-Noise Amplifier (LNA) before being fed to the GNSS RF port of the nRF9151 SiP. The LNA is powered by a ultra-low IQ (25 nA typ.) LDO (TPS7A02228) that is controlled by the nRF9151 SiP <code>COEX0</code> pin. With 18.2 dB gain and only 0.7 dB noise figure it ensures high system sensitivity.</p> <p>The following figure shows the GNSS circuitry:</p> <p></p> <p>The following figure shows how to attach the GNSS antenna:</p> <p></p> <p>Optimize GNSS reception</p> <ul> <li>GNSS signals do not usually penetrate ceilings or other structures that well. For best GNSS performance, the antenna should be placed outside on a flat surface in an open space far from sources of interference and other structures that can block the satellite signals.</li> <li>The GNSS patch antenna achieves the highest gain when placed horizontally on a surface (x-y) facing the z-axis since it can receive all propagated GNSS signals. A lower gain is experienced if the patch antenna is mounted at an angle.</li> </ul>"},{"location":"hardware/#debug-interface","title":"Debug interface","text":"<p>nRF9151 Connect Kit supports Arm Serial Wire Debug (SWD) port, which makes it possible to connect external debuggers for debug and programming. Note that the signal voltage levels of SWD should match to VDD_GPIO.</p> <p>The following figure illustrates the SWD port of the nRF9151 SiP:</p> <p></p> <p>Connect the external debugger to nRF9151</p> <p>The SWD port of nRF9151 is default connected to the Interface MCU's DAP interface. If an external debugger is wired to the SWD port of nRF9151, the Interface MCU's DAP interface should be disabled.</p> <p>The SWD port of Interface MCU (nRF52820) is also available for use. Note that the signal voltage levels of SWD should match to VDD_GPIO.</p> <p>The following figure illustrates the SWD port of the Interface MCU (nRF52820):</p> <p></p>"},{"location":"hardware/#additional-pins","title":"Additional pins","text":"<p>Additional pins are exposed on the bottom of the board for on-board functionality or external circuitry.</p> <p>The following figure illustrates the additional pins:</p> <p></p> <p>The following table describes the pin functions of the additional pins:</p> Pin Name Description TP1 IF_USB_DP USB D+ signal of the Interface MCU (nRF52820). TP2 IF_USB_DM USB D- signal of the Interface MCU (nRF52820). TP3 VBAT Battery power supply. Connect to the positive terminal of the battery. TP4 IF_RESET RESET pin of the Interface MCU (nRF52820). TP5 IF_SWCLK Serial wire debug clock input of the Interface MCU (nRF52820). TP6 IF_SWDIO Serial wire debug I/O of the Interface MCU (nRF52820). TP8 MIPI_SDIO Data pin of the nRF9151's MIPI RFFE control interface. TP9 MIPI_SCLK Clock pin of the nRF9151's MIPI RFFE control interface. TP10 MIPI_VIO Power pin of the nRF9151's MIPI RFFE control interface. TP11 MAGPIO0 1.8 V general purpose I/O of the nRF9151's MAGPIO interface. TP12 MAGPIO1 1.8 V general purpose I/O of the nRF9151's MAGPIO interface. TP13 MAGPIO2 1.8 V general purpose I/O of the nRF9151's MAGPIO interface. TP14 COEX0 nRF9151's Coexistence interface. TP15 COEX1 nRF9151's Coexistence interface. TP16 COEX1 nRF9151's Coexistence interface."},{"location":"introduction/","title":"nRF9151 Connect KitVersatile Prototyping Kit based on the nRF9151 SiP supporting LTE-M/NB-IoT Worldwide, DECT NR+ and GNSS","text":""},{"location":"introduction/#introduction","title":"Introduction","text":"<p>nRF9151 Connect Kit is a versatile prototyping kit built around the nRF9151 System-in-Package (SiP) which supports LTE-M, NB-IoT, GNSS, and DECT NR+, making it suitable for global use. It has LTE bands B1-B5, B8, B12, B13, B17-B20, B25, B26, B28, B65, B66 and B85 support, Arm TrustZone CryptoCell 310, unique modem features for further power saving and ease of use.</p> <p>The design comes with an Interface MCU built using the nRF52820, which enables debug, programming as well as modem firmware update, no need for any external tools. The Interface MCU also includes a USB-UART bridge for log, trace and terminal emulation, and an Interface Shell bundled with helpful commands to access the board-specific functionality.</p> <p>The board contains a BQ25180 I2C programmable battery charger with power path management and ultra low quiescent current, and a TPS63901 buck-boost converter with 75-nA quiescent current and 1.8V/3.3V configurable power supply for I/Os.</p> <p>It also has USB-C, LEDs, Buttons, nano-SIM card slot, Battery connector, U.FL receptacles for U.FL cabled LTE-M/NB-IoT/NR+ and GNSS antennas, Arm Serial Wire Debug (SWD) port and dual-row 40 pins with loose or pre-soldered headers available.</p> <p>nRF Connect SDK is supported, including the Zephyr RTOS, various samples, networking protocols, libraries, and hardware drivers, all essential for cellular IoT development. It is open source, and can be leveraged and modified to suit your specific needs.</p> <p></p>"},{"location":"introduction/#key-features","title":"Key Features","text":"<ul> <li> <p>Nordic Semiconductor nRF9151 SiP</p> <ul> <li>Fully integrated SiP with 64 MHz Arm Cortex-M33 and multimode LTE-M/NB-IoT modem with   DECT NR+ support and GNSS</li> <li>700-2200 MHz LTE bands: B1-B5, B8, B12, B13, B17-B20, B25, B26, B28, B65, B66, B85</li> <li>Power Class 5 20 dBm</li> <li>Power Class 3 23 dBm</li> <li>1.9GHz NR+ band support</li> <li>Certified for global operation</li> <li>Dedicated programmable application processor and memory</li> <li>1 MB Flash + 256 KB RAM</li> <li>Arm TrustZone + Arm CryptoCell 310</li> <li>4 x SPI/UART/TWI, PDM, I2S, PWM, ADC</li> </ul> </li> <li> <p>On-board Interface MCU</p> <ul> <li>Built using nRF52820 with 64 MHz Arm Cortex-M4, 256 KB Flash &amp; 32 KB RAM</li> <li>Built-in CMSIS-DAP support for debug, programming as well as modem firmware update,   no need for any external tools</li> <li>USB-UART bridge for log, trace and terminal emulation</li> <li>Interface Shell with helpful commands to access the board-specific functionality</li> <li>Self-upgradable UF2 Bootloader featuring drag-and-drop programming for Interface MCU firmware update</li> <li>Open source and more features will be released gradually over time</li> </ul> </li> <li> <p>BQ25180 I2C programmable Battery Charger with power path management and ultra low quiescent current </p> </li> <li>TPS63901 buck-boost converter with 75-nA quiescent current and 1.8V/3.3V configurable power supply for I/Os</li> <li>On-board GNSS Low Noise Amplifier (LNA) with 18.2 dB gain and only 0.7 dB noise figure for improved sensitivity</li> <li>Shipped with U.FL cabled LTE-M/NB-IoT/NR+ and GNSS antennas</li> <li>31 multi-function GPIOs (8 can be configured as ADC inputs) through edge pins</li> <li>Arm Serial Wire Debug (SWD) port through edge pins</li> <li>USB-C, LEDs, Buttons, nano-SIM card slot, Battery connector, U.FL receptacles</li> <li>Dual-row 40 pins in 55.88mm x 20.32mm (2.2\" x 0.8\") DIP/SMT form factor</li> <li>Available in Loose or Pre-soldered headers options</li> <li>Built on open source, supporting nRF Connect SDK and Zephyr RTOS, etc</li> </ul>"},{"location":"introduction/#hardware-diagram","title":"Hardware Diagram","text":""},{"location":"introduction/#whats-in-the-box","title":"What's in the box","text":"Part Quantity nRF9151 Connect Kit Board (Loose or Pre-soldered Headers) 1 U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna 1 U.FL cabled GNSS Antenna 1 Quick Start Guide 1"},{"location":"purchase/","title":"Purchase","text":""},{"location":"purchase/#buy-online","title":"Buy Online","text":"<p>nRF9151 Connect Kit is available on the following channels (click to go directly to the product):</p>"},{"location":"purchase/#request-large-volume-pricing","title":"Request Large Volume Pricing","text":"<p>Thank you for your interest in purchasing large volume from Makerdiary. In order to help you more efficiently, please contact us:</p> <p>Request Quote</p>"},{"location":"purchase/#design-customization","title":"Design &amp; Customization","text":"<p>We are ready to customize our hardware and firmware to better meet your solution's needs. Many of our platforms are prepared for customization.</p> <p>If you would like to do some serious business, feel free to contact us and we'll reply before you know it:</p> <p>Design Services</p>"},{"location":"resources/","title":"Resources","text":""},{"location":"resources/#technical-documentation","title":"Technical documentation","text":"<ul> <li>nRF9151 Connect Kit Product Brief</li> <li>nRF9151 Connect Kit Quick Start Guide</li> <li>Developing with nRF Connect SDK</li> <li>Programming Guide</li> </ul>"},{"location":"resources/#hardware-resource","title":"Hardware resource","text":"<ul> <li>nRF9151 Connect Kit Hardware Description</li> <li>nRF9151 Connect Kit Hardware Diagram</li> <li>nRF9151 Connect Kit Schematic Rev.A</li> <li>nRF9151 Connect Kit Board DXF Files Rev.A</li> <li>nRF9151 Connect Kit 3D Model Rev.A</li> </ul>"},{"location":"resources/#regulatory-compliance","title":"Regulatory &amp; Compliance","text":"<ul> <li>nRF9151 SiP Global and Regulatory</li> <li>FCC Supplier's Declaration of Conformity (SDoC)</li> <li>EU Declaration of Conformity (DoC)</li> <li>RoHS &amp; REACH Declaration of Conformity</li> </ul>"},{"location":"revision-history/","title":"Revision history","text":""},{"location":"revision-history/#hardware","title":"Hardware","text":""},{"location":"revision-history/#REVA","title":"Rev.A December 25, 2024","text":"<ul> <li>The first public release</li> </ul>"},{"location":"revision-history/#software-documentation","title":"Software &amp; Documentation","text":""},{"location":"revision-history/#DOC_V1.0.0","title":"V1.0.0 Mar 7, 2025","text":"<ul> <li>The first public release</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>It may happen that you run into trouble while getting started with your new nRF9151 Connect Kit. This page is here to help you solve the most common problems. If you have a new problem, you can create a new issue or discuss it on GitHub Discussions.</p>"},{"location":"troubleshooting/#which-com-port-is-connected-to-nrf9151-sip","title":"Which COM port is connected to nRF9151 SiP?","text":"<p>The Interface MCU exposes two COM ports, the first one acts as a UART bridge between the host and the nRF9151 SiP, and the second one is connected to the Interface Shell whose terminal prompt appears as <code>ifsh:~$</code>.</p>"},{"location":"troubleshooting/#how-to-get-a-compatible-sim-card","title":"How to get a compatible SIM Card?","text":"<ol> <li> <p>Choose a Provider: Identify a mobile network operator (MNO) or IoT service provider that offers LTE-M or NB-IoT services in your region.</p> </li> <li> <p>Request a SIM Card: Contact the provider to request a compatible SIM card. Provide details about your use case (e.g., IoT deployment, data requirements).</p> </li> <li> <p>Activate the SIM Card: Follow the provider's activation process, which may include registering the SIM card and configuring APN settings.</p> </li> </ol>"},{"location":"blog/","title":"Latest posts","text":""},{"location":"blog/introducing-interface-mcu/","title":"Introducing Interface MCU","text":""},{"location":"blog/introducing-interface-mcu/#introducing-interface-mcu","title":"Introducing Interface MCU","text":""},{"location":"blog/introducing-interface-mcu/#introduction","title":"Introduction","text":"<p>The nRF9151 Connect Kit comes with an on-board Interface MCU built using the nRF52820. The Interface MCU Firmware is running on the nRF52820. It implements a CMSIS-DAP interface for debugging and programming the nRF9151 SiP. It also exposes two USB CDC ACM devices, one acts as a UART bridge between the host and the nRF9151 SiP, the other enables an Interface Shell for accessing board-specific functionality such as battery charger settings.</p> <p>The Interface MCU also comes pre-programmed with the UF2 Bootloader, an easy-to-use and self-upgradable bootloader that can be used to update the firmware by just copying the .uf2-format images to the flash drive without using an external programmer.</p> <p>The following figure describes the functional architecture of the Interface MCU:</p> <p></p>"},{"location":"blog/introducing-interface-mcu/#why-choose-the-nrf52820","title":"Why Choose the nRF52820","text":"<p>The nRF52820, with its rich feature set and low-power design, is an excellent choice for implementing an Interface MCU.</p> <ul> <li>Low Power Consumption: Ultra-low power is in Nordic's DNA. The nRF52820 draws less than 1 \u00b5A in System OFF mode, making it an ideal choice for battery-powered applications.</li> <li>High Performance: The nRF52820 features a 64 MHz Arm Cortex-M4 processor with 256 KB Flash and 32 KB RAM.</li> <li>Full Speed USB 2.0: The nRF52820 integrates a USB 2.0 full speed (12 Mbps) controller, which allows the SoC to support multiple functions, such as HID and CDC, simultaneously.</li> <li>Cost-Effective: The nRF52820 integrates many features into a single chip, reducing the need for additional external components. This integration lowers the overall Bill of Materials (BOM).</li> <li>Comprehensive Development Ecosystem: Compatible with Nordic\u2019s nRF Connect SDK. This makes it easier to develop and debug applications.</li> </ul>"},{"location":"blog/introducing-interface-mcu/#getting-started-with-the-interface-mcu","title":"Getting Started with the Interface MCU","text":"<p>The Interface MCU firmware is open source, and detailed documentation is available to help you get started.</p> <ul> <li>Interface MCU Firmware Source Code</li> <li>Interface MCU Firmware Documentation</li> </ul>"},{"location":"blog/introducing-nrf-cloud/","title":"Introducing nRF Cloud","text":""},{"location":"blog/introducing-nrf-cloud/#introducing-nrf-cloud","title":"Introducing nRF Cloud","text":""},{"location":"blog/introducing-nrf-cloud/#what-is-nrf-cloud","title":"What is nRF Cloud?","text":"<p>nRF Cloud is a comprehensive cloud platform tailored for IoT developers. It bridges the gap between IoT devices and the cloud, offering a suite of services that streamline the entire development lifecycle. Whether you\u2019re building a small-scale prototype or a large-scale deployment, nRF Cloud provides the infrastructure and tools to make your IoT vision a reality.</p> <p></p>"},{"location":"blog/introducing-nrf-cloud/#key-features-of-nrf-cloud","title":"Key Features of nRF Cloud","text":"<ul> <li> <p>Device Management: Easily onboard, monitor, and manage your IoT devices at scale. Track device health, connectivity status, and performance in real-time.</p> </li> <li> <p>Data Visualization: Transform raw sensor data into actionable insights with customizable dashboards. Visualize trends, anomalies, and key metrics to make informed decisions.</p> </li> <li> <p>Over-the-Air (OTA) Updates: Securely deploy firmware updates to devices in the field, ensuring they stay up-to-date with the latest features and security patches.</p> </li> <li> <p>Seamless Integration: Fully compatible with Nordic\u2019s nRF91 Series and nRF Connect SDK.</p> </li> <li> <p>Security: Built-in security features, including end-to-end encryption and secure boot, protect your devices and data from threats.</p> </li> <li> <p>Scalability: Allow you to seamlessly scale from a few devices on a pilot run to thousands of devices on a production deployment.</p> </li> </ul>"},{"location":"blog/introducing-nrf-cloud/#benefits-of-nrf-cloud","title":"Benefits of nRF Cloud","text":"<ul> <li> <p>Built from the ground-up for low power: Ultra-low power is in Nordic's DNA. Everything we offer to our customers across hardware, software and cloud services, is optimized for ultra-low power. </p> </li> <li> <p>Agnostic connectivity transport: nRF Cloud can be accessed via device-to-cloud or cloud-to-cloud mechanisms, to ensure it fits a variety of use-cases and system architectures.</p> </li> <li> <p>Standalone services and pricing: Individual selection of services and features allows for a flexible adoption that meets your needs, and pricing plan options that fit the scale of your business.</p> </li> <li> <p>Full lifecycle support: nRF Cloud services can be leveraged across your product's entire lifecycle, from production to field decommissioning, reducing costs associated with proprietary infrastructure.</p> </li> </ul>"},{"location":"blog/introducing-nrf-cloud/#getting-started-with-nrf-cloud","title":"Getting Started with nRF Cloud","text":"<p>We think the best way to learn is by doing. We provides the following samples that help you to get started with nRF Cloud on the nRF9151 Connect Kit.</p> <ul> <li> <p>nRF Cloud Device Provisioning</p> <p>Demonstrate how to use the nRF Cloud device provisioning service.</p> </li> <li> <p>nRF Cloud REST Device Message</p> <p>Demonstrate how to use the nRF Cloud REST API to send Device Messages.</p> </li> <li> <p>nRF Cloud Multi-service</p> <p>Demonstrate how to integrate multiple nRF Cloud services.</p> </li> </ul>"},{"location":"blog/nrf9151-connect-kit-is-here/","title":"nRF9151 Connect Kit is Here!","text":""},{"location":"blog/nrf9151-connect-kit-is-here/#nrf9151-connect-kit-is-here","title":"nRF9151 Connect Kit is Here!","text":""},{"location":"blog/nrf9151-connect-kit-is-here/#introduction","title":"Introduction","text":"<p>Today we are excited to launch our latest IoT prototyping kit, the nRF9151 Connect Kit, for LTE-M, NB-IoT, DECT NR+, and GNSS applications. The nRF9151 Connect Kit comes with on-board Interface MCU for debug and programming, flexible power management with battery charger, easy-to-use form factor, nRF Connect SDK support including the Zephyr RTOS, various samples and documentation. It\u2019s designed to help developers quickly prototype and deploy Cellular IoT applications with minimal effort.</p>"},{"location":"blog/nrf9151-connect-kit-is-here/#why-choose-the-nrf9151-sip","title":"Why Choose the nRF9151 SiP","text":"<p>Like its predecessor, the nRF9161, the nRF9151 supports 3GPP release 14 LTE-M/NB-IoT global coverage and DECT NR+. The nRF9151 stands out from the nRF9160 and nRF9161 with its exclusive features, such as a significant footprint reduction, which allows for more compact products without performance compromises. In addition to Power class 3 (23 dBm), the nRF9151 also supports Power class 5 (20 dBm) output power, leading to 45 percent reduced peak power consumption thanks to the unique nRF9151 low power design, which decreases the cost of battery-powered products. The nRF9151 will also add support for Non-Terrestrial Network (NTN) support in a future firmware release.  </p>"},{"location":"blog/nrf9151-connect-kit-is-here/#key-features-of-the-nrf9151-connect-kit","title":"Key Features of the nRF9151 Connect Kit","text":"<ul> <li>Global Cellular Connectivity: Supports LTE-M and NB-IoT networks, ensuring reliable connectivity worldwide.</li> <li>Integrated GNSS: Built-in Global Navigation Satellite System (GNSS) enables precise location tracking for applications like asset tracking.</li> <li>On-board Interface MCU: Built-in CMSIS-DAP support for debug, programming as well as modem firmware update, no need for any external tools.</li> <li>Ultra-Low Power Design: Optimized for battery-powered devices, the kit ensures long operational life, making it ideal for remote and hard-to-reach deployments.</li> <li>Built on Open Source: Compatible with Nordic\u2019s nRF Connect SDK, including the Zephyr RTOS, various samples, networking protocols, libraries, and hardware drivers, all essential for cellular IoT development.</li> </ul>"},{"location":"blog/nrf9151-connect-kit-is-here/#join-the-cellular-iot-revolution","title":"Join the Cellular IoT Revolution","text":"<p>The nRF9151 Connect Kit is here to help you unlock the full potential of cellular IoT. With its advanced features and user-friendly design, it\u2019s the perfect platform for developers looking to innovate and lead in the low power Cellular IoT space.</p> <p>Get your nRF9151 Connect Kit today and start building the future of connected devices!</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We're really glad you're reading this, because we would love to have more developers contribute to this project! If you're passionate about making this project better, you're in the right place.</p>"},{"location":"contributing/#before-contributing","title":"Before contributing","text":"<p>If you encounter a bug or think of a useful feature, please create a new issue. Creating an issue before jumping into code ensures we can discuss it and determine whether it aligns with the direction of this project.</p> <p>If you want to contribute to the project, regardless of whether it's a small bug fix or correcting a typo, please feel free to do so. Any help goes a long way! Also, contributions aren't necessarily all code related. Other contributions can be in the form of issues, pull requests, discussions, etc.</p>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<ul> <li> <p> Something is not working?</p> <p>Report a bug by creating a new issue</p> <p> Report a bug</p> </li> <li> <p> Want to create a pull request?</p> <p>Learn how to create a pull request</p> <p> Create a pull request</p> </li> <li> <p> Have a question or need help?</p> <p>Ask a question on our discussion board and get in touch with our community</p> <p> Ask a question</p> </li> </ul>"},{"location":"contributing/creating-a-pull-request/","title":"Creating a pull request","text":"<p>You can contribute to this project by opening a pull request that will be reviewed by maintainers and integrated into the main repository when the changes made are approved. You can contribute bug fixes, changes to the documentation, or new functionality you have developed.</p> <p>You can follow these steps to create a pull request for this project:</p> <ol> <li> <p>Fork the repository, clone it and create a new branch:</p> <pre><code>git clone git@github.com:your-username/nrf9151-connectkit.git\n</code></pre> <pre><code>cd nrf9151-connectkit\n</code></pre> <pre><code>git checkout -b your-new-branch-name\n</code></pre> </li> <li> <p>Add your changes to the codebase.</p> </li> <li> <p>Commit your changes with your sign-off message:</p> <pre><code>git commit --signoff --message 'This is my commit message'\n</code></pre> <p>Tip</p> <p>A sign-off message in the following format is required on each commit in the pull request:</p> <pre><code>This is my commit message\n\nSigned-off-by: First_Name Last_Name &lt;My_Name@example.com&gt;\n</code></pre> <p>This will use your default git configuration which is found in <code>.git/config</code> and usually, it is the <code>username systemaddress</code> of the machine which you are using.</p> <p>To change this, you can use the following commands (Note these only change the current repo settings, you will need to add <code>--global</code> for these commands to change the installation default).</p> <p>Your name:</p> <pre><code>git config user.name \"First_Name Last_Name\"\n</code></pre> <p>Your email:</p> <pre><code>git config user.email \"My_Name@example.com\"\n</code></pre> </li> <li> <p>Push your commit to your forked repository:</p> <pre><code>git push origin your-new-branch-name\n</code></pre> </li> <li> <p>Create a pull request. See GitHub's official documentation for more details.</p> </li> </ol>"},{"location":"contributing/reporting-a-bug/","title":"Reporting a bug","text":"<p>Bugs are tracked as GitHub issues. Search open issues to see if someone else has reported a similar bug. If it's something new, open an issue. We'll use the issue to have a conversation about the problem you want to fix.</p> <p>When creating a new issue, please ensure the issue is clear and include additional details to help maintainers reproduce it:</p> <ul> <li>Use a clear and descriptive title for the issue to identify the problem.</li> <li>Describe the exact steps which reproduce the problem in as many details as possible.</li> <li>Provide specific examples to demonstrate the steps. Include links to files, or copy/pasteable snippets. If you're providing snippets in the issue, use Markdown code blocks.</li> <li>Describe the behavior you observed after following the steps and point out what exactly is the problem with that behavior.</li> <li>Explain which behavior you expected to see instead and why.</li> <li>Include screenshots and animated GIFs where possible.</li> </ul>"},{"location":"guides/ncs/","title":"nRF Connect SDK","text":""},{"location":"guides/ncs/#introduction","title":"Introduction","text":"<p>The nRF Connect SDK is a modern, unified software development kit for building low-power wireless applications based on the Nordic Semiconductor nRF52, nRF53, nRF54, nRF70, and nRF91 Series wireless devices. It supports Microsoft Windows, Linux, and macOS for development.</p>"},{"location":"guides/ncs/#distinguishing-features","title":"Distinguishing Features","text":"<ul> <li> <p>Based on Zephyr and open source</p> <p>The nRF Connect SDK integrates the Zephyr\u2122 real-time operating system (RTOS) and is compatible with most of Zephyr\u2019s applications and samples. Just like Zephyr, the nRF Connect SDK is open source and based on proven open-source projects.</p> </li> </ul> <ul> <li> <p>Middleware and security</p> <p>The nRF Connect SDK includes middleware from Zephyr, such as MQTT or Trusted Firmware-M for security. In addition to that, the nRF Connect SDK adds extra libraries and drivers, such as CoAP, LwM2M, a secure bootloader (MCUboot), Mbed TLS, nRF 802.15.4 Radio Driver, nRF Security, nRF Profiler, nRF Remote procedure call libraries, and many more.</p> </li> </ul> <ul> <li> <p>Pre-certified libraries</p> <p>The nRF Connect SDK provides pre-certified, optimized libraries, including for SoftDevice, Matter, and Thread.</p> </li> </ul> <ul> <li> <p>Robust connectivity support</p> <p>The nRF Connect SDK supports a wide range of connectivity technologies. In addition to connectivity technologies provided by Zephyr, such as Bluetooth\u00ae Low Energy, IPv6, TCP/IP, UDP, LoRa and LoRaWAN, the nRF Connect SDK supports ANT, Bluetooth Mesh, Apple Find My, LTE-M/NB-IoT/GPS, DECT NR+, Matter, Amazon Sidewalk, Thread, and Wi-Fi\u00ae, among others.</p> </li> </ul> <ul> <li> <p>Remote observability</p> <p>The nRF Connect SDK provides remote observability support to maintain optimal device performance and reliability in ever-changing device ecosystems after devices are deployed. Once devices are in the field, you can implement device reliability best practices such as remote debug, monitoring, and FOTA support.</p> </li> </ul> <ul> <li> <p>Scalable and extensible</p> <p>The nRF Connect SDK is out-of-tree ready and can be used for projects and applications of all sizes and levels of complexity.</p> </li> </ul> <ul> <li> <p>Third-party integrations</p> <p>The nRF Connect SDK provides integrations with third-party and Nordic products within the SDK, such as AWS, nRF Cloud, Memfault (Remote Observability) and more.</p> </li> </ul> <ul> <li> <p>Varied reference designs</p> <p>The nRF Connect SDK comes with advanced hardware reference designs for different use cases, ranging from nRF Desktop for Human Interface Devices to nRF5340 Audio for audio devices based on Bluetooth LE Audio specifications.</p> </li> </ul>"},{"location":"guides/ncs/#get-involved","title":"Get Involved","text":"<p>We think the best way to learn is by doing. The following sections take you through the basics of nRF Connect SDK development and show you how to implement typical use cases with Nordic Semiconductor libraries and drivers on the nRF9151 Connect Kit.</p> <ul> <li> <p> Getting Started Guide</p> <p>Set up a command-line development environment, build and run your first sample application.</p> <p> Learn more</p> </li> <li> <p> Applications</p> <p>Show how to implement typical user scenarios and can be served as a starting point for developing your product.</p> <p> Learn more</p> </li> <li> <p> Samples</p> <p>Show how to implement typical use cases with Nordic Semiconductor libraries and drivers.</p> <p> Learn more</p> </li> </ul>"},{"location":"guides/ncs/#reference","title":"Reference","text":"<ul> <li> <p>nRF Connect SDK Primary Git Repository</p> </li> <li> <p>nRF Connect SDK Documentation</p> </li> <li> <p>Zephyr Project Primary Git Repository</p> </li> <li> <p>Zephyr Project Documentation</p> </li> </ul>"},{"location":"guides/ncs/getting-started/","title":"Getting Started Guide","text":"<p>This guide walks you through setting up the nRF Connect SDK development environment, building and running the Hello World sample on the nRF9151 Connect Kit.</p> <p>The nRF Connect SDK is based on the Zephyr Project, which means everything required by Zephyr\u2019s Getting Started Guide is also suitable for the nRF Connect SDK.</p>"},{"location":"guides/ncs/getting-started/#select-and-update-os","title":"Select and Update OS","text":"<p>Install available updates for your operating system:</p> WindowsmacOSUbuntu <p>Select Start &gt; Settings &gt; Update &amp; Security &gt; Windows Update. Click Check for updates and install any that are available.</p> <p>On macOS Mojave or later, select System Preferences... &gt; Software Update. Click Update Now if necessary.</p> <p>On other versions, see this Apple support topic.</p> <p>This guide covers Ubuntu version 20.04 LTS and later.</p> <pre><code>sudo apt update\n</code></pre> <pre><code>sudo apt upgrade\n</code></pre>"},{"location":"guides/ncs/getting-started/#install-dependencies","title":"Install dependencies","text":"<p>Next, you\u2019ll install some host dependencies using your package manager.</p> <p>The current minimum required version for the main dependencies are:</p> Tool Min. Version CMake 3.20.5 Python 3.10 Devicetree compiler 1.4.6 WindowsmacOSUbuntu <p>Chocolatey is recommended to install dependencies here. If Chocolatey isn\u2019t an option, you can install dependencies from their respective websites and ensure the command line tools added in your <code>PATH</code> environment variable.</p> <ol> <li> <p>Install chocolatey.</p> </li> <li> <p>Open a <code>cmd.exe</code> window as Administrator. To do so, press the Windows key Win , type <code>cmd.exe</code>, right-click the result, and choose Run as Administrator.</p> </li> <li> <p>Disable global confirmation to avoid having to confirm the installation of individual programs:</p> <pre><code>choco feature enable -n allowGlobalConfirmation\n</code></pre> </li> <li> <p>Use <code>choco</code> to install the required dependencies:</p> <pre><code>choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System'\n</code></pre> <pre><code>choco install ninja gperf python311 git dtc-msys2 wget 7zip\n</code></pre> </li> <li> <p>Close the terminal window and open a new <code>cmd.exe</code> window as a regular user to continue.</p> </li> </ol> <p>Tip</p> <p>To check the list of installed packages and their versions, run the following command:</p> <pre><code>choco list -lo\n</code></pre> <ol> <li> <p>Install Homebrew:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> </li> <li> <p>After the Homebrew installation script completes, follow the on-screen instructions to add the Homebrew installation to the path.</p> Apple SiliconIntel <pre><code>(echo; echo 'eval \"$(/opt/homebrew/bin/brew shellenv)\"') &gt;&gt; ~/.zprofile\n</code></pre> <pre><code>source ~/.zprofile\n</code></pre> <pre><code>(echo; echo 'eval \"$(/usr/local/bin/brew shellenv)\"') &gt;&gt; ~/.zprofile\n</code></pre> <pre><code>source ~/.zprofile\n</code></pre> </li> <li> <p>Use <code>brew</code> to install the required dependencies:</p> <pre><code>brew install cmake ninja gperf python3 python-tk ccache qemu dtc libmagic wget openocd\n</code></pre> </li> <li> <p>Add the Homebrew Python folder to the path, in order to be able to execute <code>python</code> and <code>pip</code> as well <code>python3</code> and <code>pip3</code>.</p> <pre><code>(echo; echo 'export PATH=\"'$(brew --prefix)'/opt/python/libexec/bin:$PATH\"') &gt;&gt; ~/.zprofile\n</code></pre> <pre><code>source ~/.zprofile\n</code></pre> </li> </ol> <p>Tip</p> <p>To check the versions of these dependencies installed, run the following command:</p> <pre><code>brew list --versions\n</code></pre> <ol> <li> <p>If using an Ubuntu version older than 22.04, it is necessary to add extra repositories to meet the minimum required versions for the main dependencies listed above. In that case, download, inspect and execute the Kitware archive script to add the Kitware APT repository to your sources list. A detailed explanation of <code>kitware-archive.sh</code> can be found here kitware third-party apt repository:</p> <pre><code>wget https://apt.kitware.com/kitware-archive.sh\n</code></pre> <pre><code>sudo bash kitware-archive.sh\n</code></pre> </li> <li> <p>Use <code>apt</code> to install the required dependencies:</p> <pre><code>sudo apt install --no-install-recommends git cmake ninja-build gperf \\\nccache dfu-util device-tree-compiler wget \\\npython3-dev python3-pip python3-setuptools python3-tk python3-wheel xz-utils file \\\nmake gcc gcc-multilib g++-multilib libsdl2-dev libmagic1\n</code></pre> <p>Note</p> <p>Due to the unavailability of <code>gcc-multilib</code> and <code>g++-multilib</code> on AArch64 (ARM64) systems, you may need to remove them from the list of packages to install.</p> </li> <li> <p>Verify the versions of the main dependencies installed on your system by entering:</p> <pre><code>cmake --version\n</code></pre> <pre><code>python3 --version\n</code></pre> <pre><code>dtc --version\n</code></pre> </li> </ol>"},{"location":"guides/ncs/getting-started/#get-the-code-and-install-python-dependencies","title":"Get the code and install Python dependencies","text":"<p>To help you quickly build and run the samples on the nRF9151 Connect Kit, the primary nrf9151-connectkit repository contains the nRF Connect SDK manifest repositories, additional hardware drivers and tested samples, etc.</p> <p>In the following instructions the name <code>NCS-Project</code> is used for the workspace, however in practice its name and location can be freely chosen. You\u2019ll also install additional Python dependencies in a Python virtual environment.</p> WindowsmacOSUbuntu <ol> <li> <p>Open a <code>cmd.exe</code> terminal window as a regular user</p> </li> <li> <p>Create a new virtual environment:</p> <pre><code>python -m venv NCS-Project\\.venv\n</code></pre> </li> <li> <p>Activate the virtual environment:</p> <pre><code>NCS-Project\\.venv\\Scripts\\activate.bat\n</code></pre> <p>Once activated your shell will be prefixed with <code>(.venv)</code>. The virtual environment can be deactivated at any time by running <code>deactivate</code>.</p> <p>Note</p> <p>Remember to activate the virtual environment every time you start working.</p> </li> <li> <p>Install <code>west</code>:</p> <pre><code>pip install west\n</code></pre> </li> <li> <p>Get the latest source code:</p> <pre><code>west init -m https://github.com/makerdiary/nrf9151-connectkit --mr main NCS-Project\n</code></pre> <p>Tip</p> <p>You can initialize <code>west</code> with the revision of the project that you want to check out. For example, to check out the <code>v1.0.0</code> release, use the following command instead:</p> <pre><code>west init -m https://github.com/makerdiary/nrf9151-connectkit --mr v1.0.0 NCS-Project\n</code></pre> </li> <li> <p>Enter the following commands to clone the project repositories:</p> <pre><code>cd NCS-Project\n</code></pre> <pre><code>west update\n</code></pre> <p>After all the repositories updated, your workspace folder now looks similar to this:</p> <pre><code>NCS-Project\n|___ .venv\n|___ .west\n|___ bootloader\n|___ modules\n|___ nrf\n|___ nrf9151-connectkit\n|___ nrfxlib\n|___ test\n|___ tools\n|___ zephyr\n|___ ...\n</code></pre> </li> <li> <p>Export a Zephyr CMake package. This allows CMake to automatically load boilerplate code required for building Zephyr applications.</p> <pre><code>west zephyr-export\n</code></pre> </li> <li> <p>The Zephyr west extension command <code>west packages</code> can be used to install Python dependencies.</p> <pre><code>west packages pip --install\n</code></pre> </li> </ol> <ol> <li> <p>Create a new virtual environment:</p> <pre><code>python3 -m venv ~/NCS-Project/.venv\n</code></pre> </li> <li> <p>Activate the virtual environment:</p> <pre><code>source ~/NCS-Project/.venv/bin/activate\n</code></pre> <p>Once activated your shell will be prefixed with <code>(.venv)</code>. The virtual environment can be deactivated at any time by running <code>deactivate</code>.</p> <p>Note</p> <p>Remember to activate the virtual environment every time you start working.</p> </li> <li> <p>Install <code>west</code>:</p> <pre><code>pip install west\n</code></pre> </li> <li> <p>Get the latest source code:</p> <pre><code>west init -m https://github.com/makerdiary/nrf9151-connectkit --mr main NCS-Project\n</code></pre> <p>Tip</p> <p>You can initialize <code>west</code> with the revision of the project that you want to check out. For example, to check out the <code>v1.0.0</code> release, use the following command instead:</p> <pre><code>west init -m https://github.com/makerdiary/nrf9151-connectkit --mr v1.0.0 NCS-Project\n</code></pre> </li> <li> <p>Enter the following commands to clone the project repositories:</p> <pre><code>cd NCS-Project\n</code></pre> <pre><code>west update\n</code></pre> <p>After all the repositories updated, your workspace folder now looks similar to this:</p> <pre><code>NCS-Project\n|___ .venv\n|___ .west\n|___ bootloader\n|___ modules\n|___ nrf\n|___ nrf9151-connectkit\n|___ nrfxlib\n|___ test\n|___ tools\n|___ zephyr\n|___ ...\n</code></pre> </li> <li> <p>Export a Zephyr CMake package. This allows CMake to automatically load boilerplate code required for building Zephyr applications.</p> <pre><code>west zephyr-export\n</code></pre> </li> <li> <p>The Zephyr west extension command <code>west packages</code> can be used to install Python dependencies.</p> <pre><code>west packages pip --install\n</code></pre> </li> </ol> <ol> <li> <p>Use <code>apt</code> to install Python <code>venv</code> package:</p> <pre><code>sudo apt install python3-venv\n</code></pre> </li> <li> <p>Create a new virtual environment:</p> <pre><code>python3 -m venv ~/NCS-Project/.venv\n</code></pre> </li> <li> <p>Activate the virtual environment:</p> <pre><code>source ~/NCS-Project/.venv/bin/activate\n</code></pre> <p>Once activated your shell will be prefixed with <code>(.venv)</code>. The virtual environment can be deactivated at any time by running <code>deactivate</code>.</p> <p>Note</p> <p>Remember to activate the virtual environment every time you start working.</p> </li> <li> <p>Install <code>west</code>:</p> <pre><code>pip install west\n</code></pre> </li> <li> <p>Get the latest source code:</p> <pre><code>west init -m https://github.com/makerdiary/nrf9151-connectkit --mr main NCS-Project\n</code></pre> <p>Tip</p> <p>You can initialize <code>west</code> with the revision of the project that you want to check out. For example, to check out the <code>v1.0.0</code> release, use the following command instead:</p> <pre><code>west init -m https://github.com/makerdiary/nrf9151-connectkit --mr v1.0.0 NCS-Project\n</code></pre> </li> <li> <p>Enter the following commands to clone the project repositories:</p> <pre><code>cd NCS-Project\n</code></pre> <pre><code>west update\n</code></pre> <p>After all the repositories updated, your workspace folder now looks similar to this:</p> <pre><code>NCS-Project\n|___ .venv\n|___ .west\n|___ bootloader\n|___ modules\n|___ nrf\n|___ nrf9151-connectkit\n|___ nrfxlib\n|___ test\n|___ tools\n|___ zephyr\n|___ ...\n</code></pre> </li> <li> <p>Export a Zephyr CMake package. This allows CMake to automatically load boilerplate code required for building Zephyr applications.</p> <pre><code>west zephyr-export\n</code></pre> </li> <li> <p>The Zephyr west extension command <code>west packages</code> can be used to install Python dependencies.</p> <pre><code>west packages pip --install\n</code></pre> </li> </ol>"},{"location":"guides/ncs/getting-started/#install-the-zephyr-sdk","title":"Install the Zephyr SDK","text":"<p>The Zephyr Software Development Kit (SDK) contains toolchains for each of Zephyr\u2019s supported architectures, which include a compiler, assembler, linker and other programs required to build Zephyr applications.</p> <p>For Linux, it also contains additional host tools, such as custom QEMU and OpenOCD builds that are used to emulate, flash and debug Zephyr applications.</p> WindowsmacOSUbuntu <p>Install the Zephyr SDK using the <code>west sdk install</code>.</p> <pre><code>cd NCS-Project\\zephyr\n</code></pre> <pre><code>west sdk install -t arm-zephyr-eabi\n</code></pre> <p>Install the Zephyr SDK using the <code>west sdk install</code>.</p> <pre><code>cd ~/NCS-Project/zephyr\n</code></pre> <pre><code>west sdk install -t arm-zephyr-eabi\n</code></pre> <p>Install the Zephyr SDK using the <code>west sdk install</code>.</p> <pre><code>cd ~/NCS-Project/zephyr\n</code></pre> <pre><code>west sdk install -t arm-zephyr-eabi\n</code></pre> <p>Tip</p> <p>Using the command options, you can specify the SDK installation destination and which architecture of toolchains to install. See <code>west sdk install --help</code> for details.</p>"},{"location":"guides/ncs/getting-started/#build-the-hello-world-sample","title":"Build the Hello World sample","text":"<p>Now, you can build the Hello World sample with <code>west build</code>, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151</code>.</p> WindowsmacOSUbuntu <pre><code>cd NCS-Project\\nrf9151-connectkit\n</code></pre> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151 samples\\hello_world\n</code></pre> <pre><code>cd ~/NCS-Project/nrf9151-connectkit\n</code></pre> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151 samples/hello_world\n</code></pre> <pre><code>cd ~/NCS-Project/nrf9151-connectkit\n</code></pre> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151 samples/hello_world\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p>"},{"location":"guides/ncs/getting-started/#flash-and-run-the-sample","title":"Flash and run the sample","text":"<p>Connect the nRF9151 Connect Kit to the computer with a USB-C cable:</p> <p></p> <p>Then flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\n[0] Hello World! nrf9151_connectkit/nrf9151\n[1] Hello World! nrf9151_connectkit/nrf9151\n[2] Hello World! nrf9151_connectkit/nrf9151\n[3] Hello World! nrf9151_connectkit/nrf9151\n[4] Hello World! nrf9151_connectkit/nrf9151\n[5] Hello World! nrf9151_connectkit/nrf9151\n...\n</code></pre>"},{"location":"guides/ncs/getting-started/#next-steps","title":"Next steps","text":"<p>Explore more applications or samples running on the nRF9151 Connect Kit:</p> <ul> <li> <p>Explore applications</p> <p>Show how to implement typical user scenarios and can be served as a starting point for developing your product.</p> <p> Learn more</p> </li> <li> <p>Explore samples</p> <p>Show how to implement typical use cases with Nordic Semiconductor libraries and drivers.</p> <p> Learn more</p> </li> <li> <p>nRF Connect SDK Documentation</p> <p>Official latest documentation for the nRF Connect SDK maintained by Nordic Semiconductor.</p> <p> Learn more</p> </li> <li> <p>Zephyr Project Documentation</p> <p>Learn everything about the Zephyr Project, including architecture, features and application development, etc.</p> <p> Learn more</p> </li> </ul>"},{"location":"guides/ncs/applications/","title":"Applications","text":"<p>A set of example applications are provided to show how to implement typical user scenarios using the nRF9151 Connect Kit. Applications typically include a fully integrated software stack and can serve as a starting point for developing your product. They use interface drivers and libraries from the nRF Connect SDK and its set of repositories to implement a specific use case, while Samples showcase a single feature or library.</p> <ul> <li> <p>Interface MCU Firmware</p> <p>Enable a CMSIS-DAP interface for debug and programming, a USB-UART bridge for terminal emulation and an Interface Shell for accessing board-specific functionality.</p> </li> <li> <p>Modem Shell</p> <p>Enable you to test various connectivity features of the nRF9151 such as LTE link handling, TCP/IP connections and GNSS, etc.</p> </li> <li> <p>Serial LTE Modem</p> <p>Emulate a stand-alone LTE modem on the nRF9151. The application accepts both the modem-specific AT commands and proprietary AT commands.</p> </li> </ul>"},{"location":"guides/ncs/applications/ifmcu/","title":"Interface MCU Firmware","text":""},{"location":"guides/ncs/applications/ifmcu/#overview","title":"Overview","text":"<p>This guide walks you through building and running the Interface MCU Firmware which enables a CMSIS-DAP interface for debug and programming, a USB-UART bridge for terminal emulation and an Interface Shell for accessing board-specific functionality.</p>"},{"location":"guides/ncs/applications/ifmcu/#how-it-works","title":"How it works","text":"<p>The nRF9151 Connect Kit comes with an on-board Interface MCU built using the nRF52820. The Interface MCU Firmware is running on the nRF52820. It implements a CMSIS-DAP interface for debugging and programming the nRF9151 SiP. It also exposes two USB CDC ACM devices, one acts as a UART bridge between the host and the nRF9151 SiP, the other enables an Interface Shell for accessing board-specific functionality such as battery charger settings.</p> <p>The Interface MCU also comes pre-programmed with the UF2 Bootloader, an easy-to-use and self-upgradable bootloader that can be used to update the firmware by just copying the .uf2-format images to the flash drive without using an external programmer.</p> <p>The following figure describes the functional architecture of the Interface MCU:</p> <p></p>"},{"location":"guides/ncs/applications/ifmcu/#requirements","title":"Requirements","text":"<p>Before you start buiding the application, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/applications/ifmcu/#building-the-application","title":"Building the application","text":"<p>To build the application, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the Interface MCU Firmware on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the application using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf52820</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf52820 applications/ifmcu_firmware\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another application.</p> </li> <li> <p>After building the application successfully, the firmware with the name <code>zephyr.uf2</code> can be found in the <code>build/ifmcu_firmware/zephyr</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/applications/ifmcu/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>The application is compatible with the UF2 Bootloader, so that you can easily flash the firmware by just copying the <code>zephyr.uf2</code> file to the flash drive without using an external programmer. </p> <p>To flash the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the DFU/RST button and connect your board to the USB port of your computer. Release the DFU/RST button after your board is connected.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT. The RGB LED is breathing in red.</p> </li> <li> <p>Drag and drop <code>zephyr.uf2</code> onto the UF2BOOT volume. The RGB LED blinks red rapidly during programming.</p> </li> <li> <p>The application starts running after the firmware programming is completed.</p> </li> </ol> <p>Note</p> <p>You may experience the following errors when copying the firmware to the UF2BOOT drive on macOS 14.5 or newer:</p> <p></p> Terminal<pre><code>$ cp build/ifmcu_firmware/zephyr/zephyr.uf2 /Volumes/UF2BOOT\ncp: /Volumes/UF2BOOT/zephyr.uf2: fcopyfile failed: Input/output error\ncp: /Volumes/UF2BOOT/zephyr.uf2: fchmod failed: No such file or directory\n</code></pre> <p>Currently you can ignore these errors as the firmware programming is completed and the application should work as expected.</p>"},{"location":"guides/ncs/applications/ifmcu/#usage","title":"Usage","text":""},{"location":"guides/ncs/applications/ifmcu/#using-the-cmsis-dap-interface","title":"Using the CMSIS-DAP Interface","text":"<p>You can use the CMSIS-DAP Interface to debug or program the nRF9151 SiP.</p> <p>Before you start, a tool that supports the CMSIS-DAP protocol should be installed. pyOCD v0.36.0 or newer is highly recommended. pyOCD will be installed automatically after setting up your development environment in Getting Started Guide.</p> <p>The following sections show the typical use cases with pyOCD:</p> <ul> <li> <p>To show the connected devices, use <code>pyocd list</code>:</p> Terminal<pre><code>pyocd list\n#   Probe/Board              Unique ID               Target\n----------------------------------------------------------------\n0   ZEPHYR IFMCU CMSIS-DAP   820D9A5F0E38432F280DB   \u2714\ufe0e nrf91\n    Makerdiary               nRF9151 Connect Kit\n</code></pre> </li> <li> <p>To program the nRF9151 SiP application firmware, use <code>pyocd load</code>:</p> <pre><code>pyocd load -t nrf91 application.hex\n</code></pre> </li> <li> <p>To update the nRF9151 SiP modem firmware, run the following command:</p> <pre><code>pyocd cmd -t nrf91 -c 'nrf91-update-modem-fw -f mfw_nrf91x1_2.0.2.zip' # (1)!\n</code></pre> <ol> <li>If <code>-f</code> is specified, the modem firmware is written to the device, even if the correct version is already present.</li> </ol> </li> </ul> <p>To learn more about pyOCD, see the pyOCD Documentation.</p>"},{"location":"guides/ncs/applications/ifmcu/#using-the-usb-uart-bridge","title":"Using the USB-UART Bridge","text":"<p>The first USB CDC ACM device that the Interface MCU exposes acts as a UART bridge between the host and the nRF9151 SiP. </p> <p>To see the UART output, connect to the board with a terminal emulator, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Tip</p> <p>The default serial port settings are the following:</p> Baud rate Data bits Stop bits Parity Flow Control 115200 8 1 None None"},{"location":"guides/ncs/applications/ifmcu/#using-the-interface-shell","title":"Using the Interface Shell","text":"<p>The seconnd USB CDC ACM device that the Interface MCU exposes enables an Interface Shell for accessing the board-specific functionality.</p> <p>To interact with the Interface Shell, connect to the board with a terminal emulator, specifying the correct serial port that your computer uses to communicate with the shell:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Tip</p> <p>The default serial port settings are the following:</p> Baud rate Data bits Stop bits Parity Flow Control 115200 8 1 None None <p>Type Tab to list all supported commands. When you type a command with <code>--help</code>, the terminal shows its usage, for example <code>charger --help</code>. For more information about the commands, see the Interface Shell Command Reference.</p> Terminal<pre><code>ifsh:~$\n  bootloader  cfgsync     charger     clear       device      help\n  history     i2c         kernel      rem         reset       resize\n  retval      settings    shell       simdet      temp        version\n  viosel\nifsh:~$ charger --help\ncharger - Charger commands\n          Please refer to TI BQ25180 Datasheet for more details.\nSubcommands:\n  chgdis  : Charge Disable\n             Usage: charger chgdis [value: 0|1]\n  sysreg  : Get or Set SYS Voltage\n             Usage: charger sysreg [mode: 0-7]\n             [mode: 0-7] - VBAT+225mV(&gt;=3.8V)|4.4V|4.5V|4.6V|4.7V|4.8V|4.9V|VBUS\n  ichg  : Get or Set Fast Charge Current (0-1000mA)\n             Usage: charger ichg [current_ma: 0-1000]\n  vbatreg  : Get or Set Battery Regulation Voltage (3500-4650mV)\n             Usage: charger vbatreg [voltage_mv: 3500-4650]\n  ilim  : Get or Set Input Current Limit\n             Usage: charger ilim [level: 0-7]\n             [level: 0-7] - 50mA|100mA|200mA|300mA|400mA|500mA|700mA|1100mA\n  status  : Get Charging Status\n</code></pre>"},{"location":"guides/ncs/applications/ifmcu/#interface-shell-command-reference","title":"Interface Shell Command Reference","text":"<p>The following table describes all supported commands of the Interface Shell:</p> Command Description <code>bootloader</code> Enter Interface MCU UF2 Bootloader. <code>cfgsync</code> Store settings to the non-volatile memory. Only <code>charger</code> and <code>viosel</code> commands can affect the settings. <code>charger chgdis [0|1]</code> Charge Disable  <code>0</code> (default): Battery Charging Enabled  <code>1</code>: Battery Charging Disabled <code>charger sysreg [0-7]</code> Get or Set SYS Voltage  <code>0</code>: VBAT + 225 mV (3.8 V minimum)  <code>1</code>: 4.4V  <code>2</code> (default): 4.5V  <code>3</code>: 4.6V  <code>4</code>: 4.7V  <code>5</code>: 4.8V  <code>6</code>: 4.9V  <code>7</code>: VBUS <code>charger ichg [0-1000]</code> Get or Set Fast Charge Current (0-1000mA). Default 100mA. <code>charger vbatreg [3500-4650]</code> Get or Set Battery Regulation Voltage (3500-4650mV). Default 4200mV. <code>charger ilim [0-7]</code> Get or Set Input Current Limit  <code>0</code>: 50mA  <code>1</code>: 100mA  <code>2</code>: 200mA  <code>3</code>: 300mA  <code>4</code>: 400mA  <code>5</code> (default): 500mA  <code>6</code>: 700mA  <code>7</code>: 1100mA <code>charger status</code> Get Charging Status. <code>clear</code> Clear shell screen. <code>device list</code> List all configured devices in the devicetree. <code>help</code> Show help information. <code>history</code> Show command history. <code>i2c scan &lt;device&gt;</code> Scan I2C devices.  Use <code>device list</code> to get the I2C bus name <code>&lt;device&gt;</code>. <code>i2c recover &lt;device&gt;</code> Recovery I2C bus.  Use <code>device list</code> to get the I2C bus name <code>&lt;device&gt;</code>. <code>i2c read &lt;device&gt; &lt;addr&gt; &lt;reg&gt; [&lt;bytes&gt;]</code> Read bytes from an I2C device.  Use <code>device list</code> to get the I2C bus name <code>&lt;device&gt;</code>. <code>i2c read_byte &lt;device&gt; &lt;addr&gt; &lt;reg&gt;</code> Read a byte from an I2C device.  Use <code>device list</code> to get the I2C bus name <code>&lt;device&gt;</code>. <code>i2c direct_read &lt;device&gt; &lt;addr&gt; [&lt;bytes&gt;]</code> Read byte stream directly from an I2C device without writing a register address first.  Use <code>device list</code> to get the I2C bus name <code>&lt;device&gt;</code>. <code>i2c write &lt;device&gt; &lt;addr&gt; &lt;reg&gt; [&lt;byte1&gt;, ...]</code> Write bytes to an I2C device.  Use <code>device list</code> to get the I2C bus name <code>&lt;device&gt;</code>. <code>i2c write_byte &lt;device&gt; &lt;addr&gt; &lt;reg&gt; &lt;value&gt;</code> Write a byte to an I2C device.  Use <code>device list</code> to get the I2C bus name <code>&lt;device&gt;</code>. <code>i2c speed &lt;device&gt; &lt;speed&gt;</code> Configure I2C bus speed.  Use <code>device list</code> to get the I2C bus name <code>&lt;device&gt;</code>. <code>kernel cycles</code> Get Kernel cycles. <code>kernel reboot</code> Reboot kernel. <code>kernel sleep &lt;ms&gt;</code> Kernel sleeps for  millisecond. <code>kernel thread list</code> List kernel threads. <code>kernel thread stacks</code> List threads stack usage. <code>rem</code> Ignore lines beginning with 'rem '. <code>reset [nrf52820]</code> Reset nRF52820. <code>reset nrf9151</code> Reset nRF9151 SiP. <code>resize</code> Console gets terminal screen size or assumes <code>default</code> in case the readout fails. It must be executed after each terminal width change to ensure correct text display. <code>resize default</code> Assume 80 chars screen width and send this setting to the terminal. <code>retval</code> Print return value of most recent command. <code>settings list [subtree]</code> List all settings in a subtree (omit to list all). <code>settings read [type] &lt;name&gt;</code> Read a specific setting.  <code>type</code>: <code>string</code> or <code>hex</code> (default: <code>hex</code>) <code>settings write [type] &lt;name&gt; &lt;value&gt;</code> Write to a specific setting.  <code>type</code>: <code>string</code> or <code>hex</code> (default: <code>hex</code>) <code>settings delete &lt;name&gt;</code> Delete a specific setting. <code>shell backends</code> List active shell backends. <code>shell backspace_mode</code> Toggle backspace key mode. Some terminals are not sending separate escape code for backspace and delete key. This command forces shell to interpret delete key as backspace. <code>shell colors</code> Toggle colored syntax. <code>shell vt100</code> Toggle vt100 commands. <code>shell prompt</code> Toggle prompt. <code>shell echo</code> Toggle shell echo. <code>shell stats reset</code> Reset shell statistics for the Logger module. <code>shell stats show</code> Get shell statistics for the Logger module. <code>simdet</code> Display nano-SIM Card status. <code>temp</code> Get the die temperature of the nRF52820. <code>version [-a|--all]</code> Show Interface MCU version.  Use <code>-a</code> or <code>--all</code> option to show more details. <code>viosel [0|1]</code> Get or set VIO voltage  <code>0</code> (default): 3.3V  <code>1</code>: 1.8V"},{"location":"guides/ncs/applications/modem_shell/","title":"Modem Shell","text":""},{"location":"guides/ncs/applications/modem_shell/#overview","title":"Overview","text":"<p>The Modem Shell (MoSh) application enables you to test various connectivity features of the nRF9151 such as LTE link handling, TCP/IP connections, data throughput (iperf3 and curl), SMS, GNSS, FOTA updates and PPP.</p> <p>MoSh uses the LTE link control driver to establish an LTE connection and initializes the Zephyr shell to provide a shell command-line interface for users.</p> <p>Tip</p> <p>The nRF9151 Connect Kit comes pre-programmed with the Modem Shell application, enabling you to explore its various features right out of the box.</p>"},{"location":"guides/ncs/applications/modem_shell/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x U.FL cabled GNSS Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/applications/modem_shell/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Attach the U.FL cabled GNSS Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/applications/modem_shell/#building-the-application","title":"Building the application","text":"<p>To build the application, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the Modem Shell application on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the application using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns applications/modem_shell\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another application.</p> <p>Note</p> <p>This application has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the application successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/applications/modem_shell/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the application using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/applications/modem_shell/#testing","title":"Testing","text":"<p>After programming the application, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Wait for the LTE link to be established. Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\nTF-M isolation level is: 0x00000001\nTF-M Float ABI: Hard\nLazy stacking enabled\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\n\nReset reason: PIN reset\nmosh:~$\nMOSH version:       v2.9.99-98a5e50b9ac1\nMOSH build id:      custom\nMOSH build variant: dev\nHW version:         nRF9151 LACA A0A\nModem FW version:   mfw_nrf91x1_2.0.2\nModem FW UUID:      320176d5-9f40-45fc-923b-2661ec18d547\n\n\nModem domain event: Light search done\nNetwork registration status: searching\nCurrently active system mode: NB-IoT\nLTE cell changed: ID: 180539199, Tracking area: 7464\nModem domain event: CE-level 0\nRRC mode: Connected\nPDN event: PDP context 0 activated\nPDN event: PDP context 0, PDN type IPv4 only allowed\nModem domain event: Search done\nNetwork registration status: Connected - home network\nPSM parameter update: TAU: 1800, Active time: -1 seconds\nModem config for system mode: LTE-M - NB-IoT - GNSS\nModem config for LTE preference: LTE-M is preferred, but PLMN selection is more important\nCurrently active system mode: NB-IoT\nBattery voltage:       4520 mV\nModem temperature:     28 C\nDevice ID:             nrf-359404230074347\nOperator full name:   \"\"\nOperator short name:  \"\"\nOperator PLMN:        \"46000\"\nCurrent cell id:       180539199 (0x0AC2CF3F)\nCurrent phy cell id:   367\nCurrent band:          8\nCurrent TAC:           7464 (0x1D28)\nCurrent rsrp:          74: -67dBm\nCurrent snr:           35: 11dB\nMobile network time and date: 25/02/12,14:49:28+32\nPDP context info 1:\nCID:                0\nPDN ID:             0\nPDP context active: yes\nPDP type:           IP\nAPN:                cmnbiot\nIPv4 MTU:           1280\nIPv4 address:       100.19.132.199\nIPv6 address:       ::\nIPv4 DNS address:   120.196.165.7, 221.179.38.7\nIPv6 DNS address:   ::, ::\nRRC mode: Idle\nmosh:~$\n</code></pre> </li> <li> <p>Type Tab to list all supported commands. When you type a command with <code>--help</code>, the terminal shows its usage, for example <code>ping --help</code>:</p> Terminal<pre><code>mosh:~$\nat           clear        cloud_rest   curl         date         device       dl           fota         gnss\ngpio_count   heap         help         history      iperf3       kernel       link         location     ping\nprint        rem          resize       rest         retval       shell        sleep        sms          sock\nstartup_cmd  th           uart         version\nmosh:~$ ping --help\nUsage: ping [options] -d destination\n\n-d, --destination, [str] Name or IP address\nOptions:\n-t, --timeout, [int]     Ping timeout in milliseconds\n-c, --count, [int]       The number of times to send the ping request\n-i, --interval, [int]    Interval between successive packet transmissions\n                        in milliseconds\n-l, --length, [int]      Payload length to be sent\n-I, --cid, [int]         Use this option to bind pinging to specific CID.\n                        See link cmd for interfaces\n-6, --ipv6,              Force IPv6 usage with the dual stack interfaces\n-r, --rai                Set RAI options for ping socket. In order to use RAI,\n                        it must be enabled with 'link rai' command.\n-h, --help,              Shows this help information\n</code></pre> </li> <li> <p>Use <code>ping</code> command to test the reachability of a host on an IP network. For example:</p> <pre><code>ping -d makerdiary.com  # (1)!\n</code></pre> <ol> <li> Terminal<pre><code>mosh:~$ ping -d makerdiary.com\nInitiating ping to: makerdiary.com\nModem domain event: CE-level 0\nRRC mode: Connected\nSource IP addr: 100.19.132.199\nDestination IP addr: 23.227.38.32\nPinging makerdiary.com results: time=0.316secs, payload sent: 0, payload received 0\nPinging makerdiary.com results: time=0.927secs, payload sent: 0, payload received 0\nPinging makerdiary.com results: time=0.912secs, payload sent: 0, payload received 0\nPinging makerdiary.com results: time=0.907secs, payload sent: 0, payload received 0\nPing statistics for makerdiary.com:\n    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss)\nApproximate round trip times in milli-seconds:\n    Minimum = 316ms, Maximum = 927ms, Average = 765ms\nPinging DONE\n</code></pre> </li> </ol> </li> <li> <p>Use <code>gnss</code> command to test the GNSS functionality:</p> <pre><code>gnss start\n</code></pre> <p>Observe that the following information is displayed upon acquiring a fix:</p> Terminal<pre><code>Fix valid:          true\nLeap second valid:  false\nSleep between PVT:  false\nDeadline missed:    false\nInsuf. time window: false\nVelocity valid:     true\nScheduled download: false\nExecution time:     52587 ms\nTime:              22.02.2025 07:29:24.141\nLatitude:          22.694009\nLongitude:         113.941902\nAccuracy:          3.5 m\nAltitude:          103.4 m\nAltitude accuracy: 5.5 m\nSpeed:             0.1 m/s\nSpeed accuracy:    0.6 m/s\nV. speed:          0.2 m/s\nV. speed accuracy: 0.6 m/s\nHeading:           0.0 deg\nHeading accuracy:  180.0 deg\nPDOP:              4.6\nHDOP:              2.6\nVDOP:              3.7\nTDOP:              3.4\nGoogle maps URL:   https://maps.google.com/?q=22.694009,113.941902\nSV:  22 C/N0: 38.7 el: 42 az: 331 signal: 1 in fix: 1 unhealthy: 0\nSV:  17 C/N0: 37.7 el: 43 az: 325 signal: 1 in fix: 1 unhealthy: 0\nSV:  14 C/N0: 39.7 el: 63 az: 342 signal: 1 in fix: 1 unhealthy: 0\nSV: 195 C/N0: 40.2 el: 63 az:  55 signal: 3 in fix: 1 unhealthy: 0\nSV: 194 C/N0: 38.9 el: 61 az:  92 signal: 3 in fix: 1 unhealthy: 0\nSV:   1 C/N0: 40.1 el: 37 az:  35 signal: 1 in fix: 1 unhealthy: 0\nSV:   3 C/N0: 32.6 el: 40 az:  97 signal: 1 in fix: 1 unhealthy: 0\nSV: 199 C/N0: 31.3 el:  0 az:   0 signal: 3 in fix: 0 unhealthy: 0\nSV:  19 C/N0: 24.5 el:  0 az:   0 signal: 1 in fix: 0 unhealthy: 0\n...\n</code></pre> <p>To turn off the GNSS, run the following command:</p> <pre><code>gnss stop\n</code></pre> <p>Optimize GNSS reception</p> <ul> <li>GNSS signals do not usually penetrate ceilings or other structures that well. For best GNSS performance, the antenna should be placed outside on a flat surface in an open space far from sources of interference and other structures that can block the satellite signals.</li> <li>The GNSS patch antenna achieves the highest gain when placed horizontally on a surface (x-y) facing the z-axis since it can receive all propagated GNSS signals. A lower gain is experienced if the patch antenna is mounted at an angle.</li> </ul> </li> <li> <p>Try more commands to explore different connectivity features of the Modem Shell application.</p> </li> </ol>"},{"location":"guides/ncs/applications/serial_lte_modem/","title":"Serial LTE Modem","text":""},{"location":"guides/ncs/applications/serial_lte_modem/#overview","title":"Overview","text":"<p>The Serial LTE Modem (SLM) application can be used to emulate a stand-alone LTE modem on the nRF9151 Connect Kit. The application accepts both the modem-specific AT commands and proprietary AT commands. The AT commands are documented in the following guides:</p> <ul> <li>Modem-specific AT commands - nRF91x1 AT Commands Reference Guide</li> <li>Proprietary AT commands - SLM-specific AT commands</li> </ul>"},{"location":"guides/ncs/applications/serial_lte_modem/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x U.FL cabled GNSS Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>Serial Studio v3.0.6 or newer</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/applications/serial_lte_modem/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Attach the U.FL cabled GNSS Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/applications/serial_lte_modem/#building-the-application","title":"Building the application","text":"<p>To build the application, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the Serial LTE Modem application on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the application using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns applications/serial_lte_modem\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another application.</p> <p>Note</p> <p>This application has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the application successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/applications/serial_lte_modem/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the application using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/applications/serial_lte_modem/#testing","title":"Testing","text":"<p>After programming the application, test it by performing the following steps:</p> <ol> <li> <p>Start Serial Studio application, and complete the following steps:</p> <ol> <li>Select DEVICE SETUP -&gt; <code>Serial Port</code>.</li> <li>Select FRAME PARSING -&gt; <code>No Parsing</code>.</li> <li>Select the correct serial port that your computer uses to communicate with the nRF9151 SiP from the COM Port drop-down list.</li> <li>Select Baud Rate -&gt; <code>115200</code>, Data Bits -&gt; <code>8</code>, Parity -&gt; <code>None</code>, Stop Bits -&gt; <code>1</code>, Flow Control -&gt; <code>None</code>.</li> <li>Select Send DTR Signal.</li> <li>Click  Connect .</li> <li>Select Line Ending -&gt; <code>CR+NL</code>.</li> </ol> <p></p> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe that the board sends a <code>Ready\\r\\n</code> message on the console.</p> </li> <li> <p>Send AT commands and observe the responses from the board. See Testing scenarios for typical test cases.</p> </li> </ol>"},{"location":"guides/ncs/samples/","title":"Samples","text":"<p>We provides samples that specifically target the nRF9151 Connect Kit and show how to implement typical use cases with Nordic Semiconductor libraries and drivers.</p> <p>Samples showcase a single feature or library, while Applications include a variety of libraries to implement a specific use case.</p> <ul> <li> <p>Hello World</p> <p>The simplest Zephyr application that prints <code>Hello World</code> to the serial console.</p> </li> <li> <p>Button</p> <p>Detect the user button press. Demonstrate the use of GPIO input with interrupts.</p> </li> <li> <p>ADC</p> <p>Read analog inputs from ADC channels. Demonstrate the use of the ADC driver API.</p> </li> <li> <p>Shell</p> <p>Demonstrate how to register custom commands into the Zephyr Shell.</p> </li> <li> <p>AT Client</p> <p>Enable sending AT commands over UART to the nRF9151 modem.</p> </li> <li> <p>AT Monitor</p> <p>Demonstrate how to use the AT monitor library.</p> </li> <li> <p>Modem Battery</p> <p>Demonstrate how to obtain the battery state from the nRF9151 modem.</p> </li> <li> <p>Modem Callbacks</p> <p>Set up callbacks for Modem library initialization and shutdown calls.</p> </li> <li> <p>Modem Trace Backend</p> <p>Demonstrate how to add a user-defined modem trace backend to an application.</p> </li> <li> <p>GNSS</p> <p>Demonstrate how to use the GNSS interface to control the GNSS module.</p> </li> <li> <p>TLS Cipher Suites</p> <p>Demonstrate how to connect to a host by trying different TLS cipher suites.</p> </li> <li> <p>HTTPS Client</p> <p>Set up a TLS session towards an HTTPS server and send an HTTP request.</p> </li> <li> <p>CoAP Client</p> <p>Demonstrate how to communicate with a public CoAP server.</p> </li> <li> <p>UDP</p> <p>Demonstrate how to transmit UDP packets to a UDP server.</p> </li> <li> <p>MQTT</p> <p>Demonstrate how to connect to an MQTT broker to publish and receive messages.</p> </li> <li> <p>nRF Cloud Device Provisioning</p> <p>Demonstrate how to use the nRF Cloud device provisioning service.</p> </li> <li> <p>nRF Cloud REST Device Message</p> <p>Demonstrate how to use the nRF Cloud REST API to send Device Messages.</p> </li> <li> <p>nRF Cloud Multi-service</p> <p>Demonstrate how to integrate multiple nRF Cloud services.</p> </li> </ul> <p>The Zephyr Project and the nRF Connect SDK also provide a comprehensive collection of samples and demos. Refer to their documentation for more details:</p> <ul> <li> <p>Zephyr Samples and Demos</p> </li> <li> <p>nRF Connect SDK Samples and Demos</p> </li> </ul>"},{"location":"guides/ncs/samples/adc/","title":"ADC","text":""},{"location":"guides/ncs/samples/adc/#overview","title":"Overview","text":"<p>This sample demonstrates how to use the ADC driver API. It reads ADC samples from two channels specified in the devicetree and prints the readings on the console. If voltage of the used reference can be obtained, the raw readings are converted to millivolts.</p> <p>Here is a minimal devicetree fragment which supports this sample.</p> nrf9151_connectkit_nrf9151.overlay<pre><code>/ {\n    zephyr,user {\n        io-channels = &lt;&amp;adc 0&gt;, &lt;&amp;adc 1&gt;;\n    };\n};\n\n&amp;adc {\n    #address-cells = &lt;1&gt;;\n    #size-cells = &lt;0&gt;;\n\n    channel@0 {\n        reg = &lt;0&gt;;\n        zephyr,gain = \"ADC_GAIN_1_6\";\n        zephyr,reference = \"ADC_REF_INTERNAL\";\n        zephyr,acquisition-time = &lt;ADC_ACQ_TIME_DEFAULT&gt;;\n        zephyr,input-positive = &lt;NRF_SAADC_AIN0&gt;; /* P0.13 */\n        zephyr,resolution = &lt;14&gt;;\n        zephyr,oversampling = &lt;8&gt;;\n    };\n\n    channel@1 {\n        reg = &lt;1&gt;;\n        zephyr,gain = \"ADC_GAIN_1_6\";\n        zephyr,reference = \"ADC_REF_INTERNAL\";\n        zephyr,acquisition-time = &lt;ADC_ACQ_TIME_DEFAULT&gt;;\n        zephyr,input-positive = &lt;NRF_SAADC_VDD&gt;;\n        zephyr,resolution = &lt;14&gt;;\n        zephyr,oversampling = &lt;8&gt;;\n    };\n};\n</code></pre> <p>As shown, AIN0 is assigned to Channel 0, and VDD_GPIO to Channel 1.</p>"},{"location":"guides/ncs/samples/adc/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/adc/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the ADC sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151 samples/adc\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Tip</p> <p>You can also build this sample for the <code>nrf9151_connectkit/nrf9151/ns</code> target. In such a case, the sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/adc\n</code></pre> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/adc/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Connect the nRF9151 Connect Kit to the computer with a USB-C cable:</p> <p></p> <p>Then flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/adc/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nADC reading[0]:\n- adc@e000, channel 0: 2379 = 522 mV\n- adc@e000, channel 1: 15070 = 3311 mV\nADC reading[1]:\n- adc@e000, channel 0: 2392 = 525 mV\n- adc@e000, channel 1: 15069 = 3311 mV\nADC reading[2]:\n- adc@e000, channel 0: 2354 = 517 mV\n- adc@e000, channel 1: 15074 = 3312 mV\nADC reading[3]:\n- adc@e000, channel 0: 2365 = 519 mV\n- adc@e000, channel 1: 15065 = 3310 mV\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/at_client/","title":"AT Client","text":""},{"location":"guides/ncs/samples/at_client/#overview","title":"Overview","text":"<p>The AT Client sample demonstrates the asynchronous serial communication taking place over UART to the nRF9151 modem. It acts as a proxy for sending directives to the modem using AT commands. This facilitates the reading of responses or analyzing of events related to the modem.</p> <p>For more information on the AT commands, see the nRF91x1 AT Commands Reference Guide.</p>"},{"location":"guides/ncs/samples/at_client/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/at_client/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/at_client/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the AT Client sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/at_client\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/at_client/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/at_client/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Once the sample starts running, you should see the following output:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nThe AT host sample started\nReady\n</code></pre> </li> <li> <p>Test the following commands from the terminal:</p> <pre><code>AT+CGMI # (1)!\n</code></pre> <ol> <li>This command retrieves the manufacturer identification.     Terminal<pre><code>Nordic Semiconductor ASA\nOK\n</code></pre></li> </ol> <pre><code>AT+CGMM # (1)!\n</code></pre> <ol> <li>This command retrieves the System in Package (SiP) model identification.     Terminal<pre><code>nRF9151-LACA\nOK\n</code></pre></li> </ol> <pre><code>AT+CGMR # (1)!\n</code></pre> <ol> <li>This command retrieves the modem firmware revision identification.     Terminal<pre><code>mfw_nrf91x1_2.0.2\nOK\n</code></pre></li> </ol> <pre><code>AT+CGSN=1 # (1)!\n</code></pre> <ol> <li>This command retrieves the IMEI.     Terminal<pre><code>+CGSN: \"35940423XXXXXXX\"\nOK\n</code></pre></li> </ol> <pre><code>AT+CFUN? # (1)!\n</code></pre> <ol> <li> <p>This command reads the current functional mode.     Terminal<pre><code>+CFUN: &lt;fun&gt;\nOK\n</code></pre></p> <p>The read response parameter and its defined value are the following:</p> <p><code>&lt;fun&gt;</code></p> <ul> <li>0 \u2013 Minimum functionality mode. RF circuits are disabled by deactivating LTE and GNSS services.</li> <li>1 \u2013 Normal mode. The active mode is either LTE or GNSS, or both. Full functional mode. Active modes depend on <code>%XSYSTEMMODE</code> setting.</li> <li>2 \u2013 Receive only mode in active system mode. Active modes depend on <code>%XSYSTEMMODE</code> setting.</li> <li>4 \u2013 Flight mode. RF circuits are disabled by deactivating LTE and GNSS services.</li> <li>21 \u2013 LTE is activated.</li> <li>31 \u2013 GNSS is activated.</li> <li>41 \u2013 UICC is activated.</li> </ul> </li> </ol> <pre><code>AT+CFUN=1 # (1)!\n</code></pre> <ol> <li>This command sets the functional mode of the modem to normal.     Terminal<pre><code>OK\n</code></pre></li> </ol> <pre><code>AT+CIMI # (1)!\n</code></pre> <ol> <li>This command reads the IMSI from the SIM card.     Terminal<pre><code>4600446364XXXXX\nOK\n</code></pre></li> </ol> </li> </ol> <p>Tip</p> <p>You can refer to the nRF91x1 AT Commands Reference Guide to test more AT commands.</p>"},{"location":"guides/ncs/samples/at_monitor/","title":"AT Monitor","text":""},{"location":"guides/ncs/samples/at_monitor/#overview","title":"Overview","text":"<p>The AT monitor sample demonstrates how to use the AT monitor library and define AT monitors to receive AT notifications from the Modem library.</p> <p>The sample defines two AT monitors, one for network status notifications (<code>+CEREG</code>) and one for received signal quality parameters notifications (<code>+CESQ</code>) through the <code>AT_MONITOR()</code> macro. The sample then subscribes to both notifications and switches the modem to function mode one to register to the network. While the device is registering to the network, the sample uses one of the AT monitors to determine if the registration is complete and monitors the signal quality using the other monitor. Once the device registers with the network, the sample reads the modem PSM mode status, enables it, and reads the PSM mode status again.</p>"},{"location":"guides/ncs/samples/at_monitor/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/at_monitor/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/at_monitor/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the AT Monitor sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/at_monitor\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/at_monitor/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/at_monitor/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nAT Monitor sample started\nSubscribing to notifications\nConnecting to network\nResuming link quality monitor for AT notifications\nWaiting for network\nLink quality: -73 dBm\nNetwork registration status: searching\nNetwork registration status: home\nNetwork connection ready\nPausing link quality monitor for AT notifications\nReading PSM info...\n  PSM: enabled\n  Periodic TAU string: 00000110\n  Active time string: 00100001\nEnabling PSM\nReading PSM info...\n  PSM: enabled\n  Periodic TAU string: 00000110\n  Active time string: 00100001\nModem response:\n+CEREG: 1,1\nOK\nShutting down modem\nNetwork registration status: no network\nBye\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/button/","title":"Button","text":""},{"location":"guides/ncs/samples/button/#overview","title":"Overview","text":"<p>A simple button sample demonstrates the use of GPIO input with interrupts. The sample prints a message to the console each time a button is pressed.</p>"},{"location":"guides/ncs/samples/button/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/button/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the Button sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151 samples/button\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Tip</p> <p>You can also build this sample for the <code>nrf9151_connectkit/nrf9151/ns</code> target. In such a case, the sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/button\n</code></pre> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/button/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Connect the nRF9151 Connect Kit to the computer with a USB-C cable:</p> <p></p> <p>Then flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/button/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Press the USR/P25 button and observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nSet up button at gpio@842500 pin 25\nPress the button\nButton pressed at 500938\nButton pressed at 524745\nButton pressed at 539674\nButton pressed at 548661\nButton pressed at 562823\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/coap_client/","title":"CoAP Client","text":""},{"location":"guides/ncs/samples/coap_client/#overview","title":"Overview","text":"<p>The CoAP Client sample demonstrates the communication between a public CoAP server and a CoAP client application that is running on the nRF9151 Connect Kit.</p>"},{"location":"guides/ncs/samples/coap_client/#how-it-works","title":"How it works","text":"<p>The CoAP Client sample performs the following actions:</p> <ul> <li>Connect to the configured public CoAP test server (specified by the Kconfig option <code>CONFIG_COAP_SERVER_HOSTNAME</code>).</li> <li>Send periodic GET request for a test resource (specified by the Kconfig option <code>CONFIG_COAP_RESOURCE</code>) that is available on the server.</li> <li>Display the received data about the resource on a terminal emulator.</li> </ul> <p>The public CoAP server used in this sample is Californium CoAP server (<code>coap://californium.eclipseprojects.io:5683</code>). This server runs Eclipse Californium, which is an open source implementation of the CoAP protocol that is targeted at the development and testing of IoT applications.</p> <p>This sample uses the resource obs (Californium observable resource) in the communication between the CoAP client and the public CoAP server. The communication follows the standard request/response pattern and is based on the change in the state of the value of the resource. The sample queries one resource at a time. To configure other resources, use the Kconfig option <code>CONFIG_COAP_RESOURCE</code>.</p>"},{"location":"guides/ncs/samples/coap_client/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/coap_client/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/coap_client/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the CoAP Client sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/coap_client\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/coap_client/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/coap_client/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\n[00:00:00.276,611] &lt;inf&gt; coap_client_sample: The CoAP client sample started\n[00:00:00.276,641] &lt;inf&gt; coap_client_sample: Bringing network interface up and connecting to the network\n[00:00:00.606,689] &lt;inf&gt; coap_client_sample: Waiting for network connectivity\n[00:01:29.888,641] &lt;inf&gt; coap_client_sample: Network connectivity established\n[00:01:31.571,136] &lt;inf&gt; coap_client_sample: IPv4 Address found 20.47.97.44\n[00:01:31.571,594] &lt;inf&gt; coap_client_sample: Initializing CoAP client\n[00:01:31.573,699] &lt;inf&gt; coap_client_sample: CoAP GET request sent sent to californium.eclipseprojects.io, resource: obs\n[00:01:31.906,280] &lt;inf&gt; coap_client_sample: CoAP response: code: 0x45, payload: 07:30:40\n[00:01:36.575,897] &lt;inf&gt; coap_client_sample: CoAP GET request sent sent to californium.eclipseprojects.io, resource: obs\n[00:01:37.554,443] &lt;inf&gt; coap_client_sample: CoAP response: code: 0x45, payload: 07:30:45\n[00:01:41.578,094] &lt;inf&gt; coap_client_sample: CoAP GET request sent sent to californium.eclipseprojects.io, resource: obs\n[00:01:42.045,623] &lt;inf&gt; coap_client_sample: CoAP response: code: 0x45, payload: 07:30:50\n[00:01:46.580,322] &lt;inf&gt; coap_client_sample: CoAP GET request sent sent to californium.eclipseprojects.io, resource: obs\n[00:01:47.234,832] &lt;inf&gt; coap_client_sample: CoAP response: code: 0x45, payload: 07:30:55\n[00:01:51.582,550] &lt;inf&gt; coap_client_sample: CoAP GET request sent sent to californium.eclipseprojects.io, resource: obs\n[00:01:52.324,981] &lt;inf&gt; coap_client_sample: CoAP response: code: 0x45, payload: 07:31:00\n[00:01:56.584,747] &lt;inf&gt; coap_client_sample: CoAP GET request sent sent to californium.eclipseprojects.io, resource: obs\n[00:01:57.122,161] &lt;inf&gt; coap_client_sample: CoAP response: code: 0x45, payload: 07:31:05\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/gnss/","title":"GNSS","text":""},{"location":"guides/ncs/samples/gnss/#overview","title":"Overview","text":"<p>The GNSS sample demonstrates how to use the GNSS interface to control the GNSS module.</p> <p>The sample first initializes the GNSS module. Then it handles events from the interface, reads the associated data and outputs information to the console. Because NMEA data needs to be read as soon as an NMEA event is received, a Zephyr message queue is used for buffering the NMEA strings. The event handler function reads the received NMEA strings and puts those into the message queue. The consumer loop reads from the queue and outputs the strings to the console.</p>"},{"location":"guides/ncs/samples/gnss/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x U.FL cabled GNSS Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/gnss/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Attach the U.FL cabled GNSS Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/gnss/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the GNSS sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/gnss\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/gnss/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/gnss/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe that the following information is displayed in the terminal:</p> Terminal<pre><code>Tracking:  0 Using:  0 Unhealthy: 0\n-----------------------------------\nSeconds since last fix: 5\nSearching [/]\n\nNMEA strings:\n\n$GPGGA,000005.14,,,,,0,,99.99,,M,,M,,*66\n$GPGLL,,,,,000005.14,V,N*4A\n$GPGSA,A,1,,,,,,,,,,,,,99.99,99.99,99.99,1*2D\n$GPGSV,1,1,0,,,,,,,,,,,,,,,,,1*54\n$GPRMC,000005.14,V,,,,,,,060180,,,N,V*08\n</code></pre> </li> <li> <p>Observe that the following information is displayed upon acquiring a fix:</p> Terminal<pre><code>Tracking: 12 Using: 10 Unhealthy: 0\n-----------------------------------\nLatitude:          22.693996\nLongitude:         113.941899\nAccuracy:          1.6 m\nAltitude:          104.9 m\nAltitude accuracy: 3.5 m\nSpeed:             0.2 m/s\nSpeed accuracy:    0.4 m/s\nV. speed:          0.2 m/s\nV. speed accuracy: 0.5 m/s\nHeading:           0.0 deg\nHeading accuracy:  180.0 deg\nDate:              2025-02-22\nTime (UTC):        07:27:23.089\nPDOP:              2.7\nHDOP:              1.1\nVDOP:              2.5\nTDOP:              1.9\n\nNMEA strings:\n\n$GPGGA,072723.09,2241.63975,N,11356.51394,E,1,10,1.08,104.91,M,,M,,*7C\n$GPGLL,2241.63975,N,11356.51394,E,072723.09,A,A*62\n$GPGSA,A,3,01,03,14,17,19,22,30,194,195,199,,,2.72,1.08,2.50,1*2C\n$GPGSV,5,1,18,1,38,035,36,2,36,238,,3,40,099,37,6,33,230,26,1*6E\n$GPGSV,5,2,18,7,39,211,,8,06,078,,9,-2,153,25,14,62,341,43,1*42\n$GPGSV,5,3,18,17,42,323,40,19,24,291,24,21,04,042,,22,41,330,38,1*60\n$GPGSV,5,4,18,30,42,225,39,31,45,231,,194,61,091,34,195,63,056,39,1*60\n$GPGSV,5,5,18,196,23,125,,199,59,149,33,1*65\n$GPRMC,072723.09,A,2241.63975,N,11356.51394,E,0.30,0.00,220225,,,A,V*29\n...\n</code></pre> </li> </ol> <p>Optimize GNSS reception</p> <ul> <li>GNSS signals do not usually penetrate ceilings or other structures that well. For best GNSS performance, the antenna should be placed outside on a flat surface in an open space far from sources of interference and other structures that can block the satellite signals.</li> <li>The GNSS patch antenna achieves the highest gain when placed horizontally on a surface (x-y) facing the z-axis since it can receive all propagated GNSS signals. A lower gain is experienced if the patch antenna is mounted at an angle.</li> </ul>"},{"location":"guides/ncs/samples/hello_world/","title":"Hello World","text":""},{"location":"guides/ncs/samples/hello_world/#overview","title":"Overview","text":"<p>The Hello World sample can be served as a start point of Zephyr application development. This sample is quite simple and just prints <code>Hello World</code> to the serial console.</p>"},{"location":"guides/ncs/samples/hello_world/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/hello_world/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the Hello World sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151 samples/hello_world\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Tip</p> <p>You can also build this sample for the <code>nrf9151_connectkit/nrf9151/ns</code> target. In such a case, the sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/hello_world\n</code></pre> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/hello_world/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Connect the nRF9151 Connect Kit to the computer with a USB-C cable:</p> <p></p> <p>Then flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/hello_world/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\n[0] Hello World! nrf9151_connectkit/nrf9151\n[1] Hello World! nrf9151_connectkit/nrf9151\n[2] Hello World! nrf9151_connectkit/nrf9151\n[3] Hello World! nrf9151_connectkit/nrf9151\n[4] Hello World! nrf9151_connectkit/nrf9151\n[5] Hello World! nrf9151_connectkit/nrf9151\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/https_client/","title":"HTTPS Client","text":""},{"location":"guides/ncs/samples/https_client/#overview","title":"Overview","text":"<p>The HTTPS Client sample demonstrates a minimal implementation of HTTP communication. It shows how to set up a TLS session towards an HTTPS server and how to send an HTTP request.</p>"},{"location":"guides/ncs/samples/https_client/#how-it-works","title":"How it works","text":"<p>The sample first initializes the Modem library and AT communications. Next, it provisions a root CA certificate to the modem using the Modem key management library. The sample then establishes a connection to the network, sets up the necessary TLS socket options, and connects to an HTTPS server. It sends an HTTP HEAD request and prints the response code in the terminal.</p> <p>The sample connects to <code>example.com</code>, which requires an X.509 certificate. This certificate is provided in the <code>https_client/cert</code> folder. The certificate is automatically converted to a HEX format in the <code>CMakeLists.txt</code> file. The generated <code>.inc</code> file is then included in the code, where it is provisioned to the modem.</p>"},{"location":"guides/ncs/samples/https_client/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/https_client/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/https_client/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the HTTPS Client sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/https_client\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/https_client/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/https_client/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nHTTPS client sample started\nBringing network interface up\nProvisioning certificate\nCertificate mismatch\nProvisioning certificate to the modem\nConnecting to the network\n+CGEV: EXCE STATUS 0\n%MDMEV: SEARCH STATUS 1\n+CEREG: 2,\"1D23\",\"0D70394D\",9\n%MDMEV: PRACH CE-LEVEL 0\n+CSCON: 1\n+CGEV: ME PDN ACT 0,0\n+CNEC_ESM: 50,0\n%MDMEV: SEARCH STATUS 2\n+CEREG: 1,\"1D23\",\"0D70394D\",9,,,\"00100001\",\"00000110\"\nNetwork connectivity established and IP address assigned\nLooking up example.com\nResolved 23.215.0.136 (AF_INET)\nConnecting to example.com:443\nSent 61 bytes\nReceived 345 bytes\n\n&gt;        HTTP/1.1 200 OK\n\nFinished, closing socket.\n+CEREG: 0\n+CGEV: ME DETACH\n+CSCON: 0\nNetwork connectivity lost\nDisconnected from the network\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/modem_battery/","title":"Modem Battery","text":""},{"location":"guides/ncs/samples/modem_battery/#overview","title":"Overview","text":"<p>The Modem Battery sample demonstrates how to obtain the following battery related information from the modem using the Modem battery library:</p> <ul> <li>Modem battery voltage</li> <li>Modem battery voltage low level notifications</li> <li>Power-off warnings</li> </ul>"},{"location":"guides/ncs/samples/modem_battery/#how-it-works","title":"How it works","text":"<p>The sample first calls the <code>modem_battery_low_level_handler_set()</code> and <code>modem_battery_pofwarn_handler_set()</code> functions to set the respective handlers, and then sets up the workqueues used to handle the low level battery voltage notifications and the power-off warning notifications. The sample then initializes the Modem library. Next, it enters a state machine that measures the modem battery voltage at every iteration and then executes an activity based on that. The first activity (<code>init_activity()</code>) sets the modem to receive-only mode if the battery voltage drops below the low level threshold or to normal mode if it rises above the threshold and updates the state accordingly.</p> <p>Then, depending on the modem\u2019s battery voltage, the modem switches mode according to the following conditions:</p> <ul> <li>If the modem is in normal mode and the battery voltage drops below the low level threshold, the modem switches to receive-only mode.</li> <li>If the modem is in receive-only mode and the battery voltage is below the low level threshold, the application periodically checks the battery voltage and switches state if it rises above the low level threshold.</li> <li>If the modem is in receive-only mode and the battery voltage is above the low level threshold, the application executes a connectivity evaluation and if the conditions are either normal (<code>7</code>), good (<code>8</code>), or excellent (<code>9</code>), the modem switches to normal mode. When connectivity conditions are poor, the number of packets re-transmitted is higher thus causing an increase in power consumption, which must be avoided when battery voltage is not at an adequately safe level. Full connectivity is recommended when battery voltage is at a sufficient level.</li> <li>If the modem is in normal mode and the battery voltage is above the low level threshold, the application executes some IP traffic (DNS lookup) to maintain an active LTE connection. The modem performs background monitoring of the battery voltage and sends a notification of low level in case it drops below the set threshold.</li> <li>If the modem battery voltage drops below the power-off warning level, the modem is automatically set offline by the hardware.</li> <li>If the modem battery voltage rises above the power-off warning level, the modem is set to receive-only mode and initialized.</li> </ul>"},{"location":"guides/ncs/samples/modem_battery/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/modem_battery/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/modem_battery/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the Modem Battery sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/modem_battery\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/modem_battery/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/modem_battery/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nBattery sample started\nInitializing modem library\nBattery voltage: 4520\nSetting modem to normal mode...\nNormal mode set.\nConnected.\nBattery voltage: 4524\nExecuting DNS lookup for 'example.com'...\nBattery voltage: 4520\nExecuting DNS lookup for 'google.com'...\nBattery voltage: 4516\nExecuting DNS lookup for 'apple.com'...\nBattery voltage: 4516\nExecuting DNS lookup for 'amazon.com'...\nBattery voltage: 4520\nExecuting DNS lookup for 'microsoft.com'...\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/modem_callbacks/","title":"Modem Callbacks","text":""},{"location":"guides/ncs/samples/modem_callbacks/#overview","title":"Overview","text":"<p>The Modem Callbacks sample demonstrates how to set up callbacks for Modem library initialization and shutdown calls, using the Modem library integration layer and how to set up a callback for changes to the modem functional mode using the LTE link control library.</p> <p>The sample performs the following operations:</p> <ol> <li> <p>Registers callbacks during compile time for modem initialization, functional mode changes, and shutdown using the <code>NRF_MODEM_LIB_ON_INIT</code>, <code>NRF_MODEM_LIB_ON_CFUN</code> and <code>NRF_MODEM_LIB_ON_SHUTDOWN</code> macros respectively.</p> </li> <li> <p>Initializes the Modem library.</p> </li> <li> <p>Changes functional mode using the <code>lte_lc_func_mode_set()</code> function in the LTE link control library</p> </li> <li> <p>Shuts down the Modem library.</p> </li> </ol> <p>This triggers the callbacks for <code>on_modem_init()</code>, <code>on_cfun()</code> and <code>on_modem_shutdown()</code> functions.</p>"},{"location":"guides/ncs/samples/modem_callbacks/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/modem_callbacks/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/modem_callbacks/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the Modem Callbacks sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/modem_callbacks\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/modem_callbacks/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/modem_callbacks/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nModem callbacks sample started\nInitializing modem library\n&gt; Initialized with value 0\nConnecting to network\n&gt; Functional mode has changed to 1\nShutting down modem library\n&gt; Shutting down\n&gt; Functional mode has changed to 0\nBye\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/modem_trace_backend/","title":"Modem Trace Backend","text":""},{"location":"guides/ncs/samples/modem_trace_backend/#overview","title":"Overview","text":"<p>The Modem Trace Backend sample demonstrates how to add a user-defined modem trace backend to an application.</p> <p>The sample implements and selects a custom trace backend to receive traces from the modem. For demonstration purposes, the custom trace backend counts the number of bytes received and calculates the data rate of modem traces received. The CPU utilization is also measured. The byte count, data rate, and CPU load are periodically printed to terminal using a delayable work item and the system workqueue.</p> <p>The custom trace backend is implemented in <code>modem_trace_backend/src/trace_print_stats.c</code>. However, it is possible to add a custom modem trace backend as a library and use it in more than one application. See Adding custom trace backends for details.</p>"},{"location":"guides/ncs/samples/modem_trace_backend/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/modem_trace_backend/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/modem_trace_backend/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the Modem Trace Backend sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/modem_trace_backend\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/modem_trace_backend/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/modem_trace_backend/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\nTF-M Float ABI: Hard\nLazy stacking enabled\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nModem trace backend sample started\nInitializing modem library\nCustom trace backend initialized\nConnecting to network\nLTE mode changed to 1\nTraces received:  11.9kB, 23.8kB/s, CPU-load:  2.65%\nTraces received:  15.2kB,  6.6kB/s, CPU-load:  1.03%\nTraces received:  18.4kB,  6.3kB/s, CPU-load:  1.03%\nTraces received:  26.2kB, 15.5kB/s, CPU-load:  0.99%\nTraces received:  27.9kB,  3.3kB/s, CPU-load:  0.94%\nTraces received:  66.5kB, 76.4kB/s, CPU-load:  2.67%\nTraces received: 103.7kB, 73.7kB/s, CPU-load:  2.79%\nTraces received: 141.7kB, 75.2kB/s, CPU-load:  2.89%\nTraces received: 180.0kB, 76.1kB/s, CPU-load:  2.83%\nTraces received: 217.9kB, 74.9kB/s, CPU-load:  2.83%\nLTE mode changed to 0\nCustom trace backend deinitialized\nBye\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/mqtt/","title":"MQTT","text":""},{"location":"guides/ncs/samples/mqtt/#overview","title":"Overview","text":"<p>The MQTT sample demonstrates how to communicate with an MQTT broker.</p> <p>The sample connects to an LTE network using the Connection Manager. Then it connects to a configured MQTT server (default is test.mosquitto.org), where it publishes messages to the topic <code>&lt;clientID&gt;/my/publish/topic</code>. You can also trigger message publication by pressing the USR/P25 button on the board.</p> <p>The sample also subscribes to the topic <code>&lt;clientID&gt;/my/subscribe/topic</code>, and receives any message published to that topic.</p> <p>The sample supports Transport Layer Security (TLS) and it can be enabled through overlay configuration files included in the sample.</p>"},{"location":"guides/ncs/samples/mqtt/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>An MQTT Client such as MQTTX for testing</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/mqtt/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/mqtt/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the MQTT sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> Unencrypted (default)Encrypted <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/mqtt\n</code></pre> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/mqtt -- -DEXTRA_CONF_FILE=overlay-tls-nrf91.conf\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/mqtt/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/mqtt/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Start MQTTX, set up a New Connection and then Connect:</p> Unencrypted (default)Encrypted <ul> <li>Host: <code>test.mosquitto.org</code></li> <li>Port: <code>1883</code></li> <li>MQTT Version: <code>3.1.1</code></li> </ul> <p></p> <ul> <li>Host: <code>test.mosquitto.org</code></li> <li>Port: <code>8883</code></li> <li>SSL/TLS: Yes</li> <li>CA File: mosquitto.org.crt (PEM format)</li> <li>MQTT Version: <code>3.1.1</code></li> </ul> <p></p> </li> <li> <p>Click New Subscription, subscribe the topic <code>&lt;clientID&gt;/my/publish/topic</code>, and Confirm:</p> <p></p> </li> <li> <p>Wait for the nRF9151 Connect Kit connecting to the newtwork. MQTTX will display the messages that the board published to <code>&lt;clientID&gt;/my/publish/topic</code>. You can also trigger message publication by pressing the USR/P25 button on the board.</p> <p></p> </li> <li> <p>In the MQTTX client, you can pushlish messages to the topic <code>&lt;clientID&gt;/my/subscribe/topic</code>. The nRF9151 Connect Kit will display the messages published to that topic.</p> <p></p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Unencrypted (default)Encrypted Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\n[00:00:00.379,119] &lt;inf&gt; network: Bringing network interface up and connecting to the network\n+CGEV: EXCE STATUS 0\n%MDMEV: SEARCH STATUS 1\n+CEREG: 2,\"1D23\",\"0D71994D\",9\n%MDMEV: PRACH CE-LEVEL 0\n+CSCON: 1\n+CGEV: ME PDN ACT 0,0\n+CNEC_ESM: 50,0\n%MDMEV: SEARCH STATUS 2\n+CEREG: 1,\"1D23\",\"0D71994D\",9,,,\"00100001\",\"00000110\"\n[00:01:28.466,186] &lt;inf&gt; network: Network connectivity established\n%MDMEV: PRACH CE-LEVEL 1\n[00:01:38.957,092] &lt;inf&gt; transport: Connected to MQTT broker\n[00:01:38.957,153] &lt;inf&gt; transport: Hostname: test.mosquitto.org\n[00:01:38.957,183] &lt;inf&gt; transport: Client ID: 359404230074347\n[00:01:38.957,214] &lt;inf&gt; transport: Port: 1883\n[00:01:38.957,244] &lt;inf&gt; transport: TLS: No\n[00:01:38.957,305] &lt;inf&gt; transport: Subscribing to: 359404230074347/my/subscribe/topic\n[00:01:39.359,863] &lt;inf&gt; transport: Subscribed to topic 359404230074347/my/subscribe/topic\n%MDMEV: PRACH CE-LEVEL 0\n%MDMEV: PRACH CE-LEVEL 1\n[00:02:00.381,530] &lt;inf&gt; transport: Published message: \"Hello MQTT! Current uptime is: 120380\" on topic: \"359404230074347/my/publish/topic\"\n%MDMEV: PRACH CE-LEVEL 0\n+CSCON: 0\n+CEREG: 1,\"1D23\",\"0D70394D\",9,,,\"00100001\",\"00000110\"\n[00:03:00.387,939] &lt;inf&gt; transport: Published message: \"Hello MQTT! Current uptime is: 180380\" on topic: \"359404230074347/my/publish/topic\"\n%MDMEV: PRACH CE-LEVEL 1\n+CSCON: 1\n[00:03:23.481,872] &lt;inf&gt; transport: Published message: \"Hello MQTT! Current uptime is: 203480\" on topic: \"359404230074347/my/publish/topic\"\n[00:03:35.287,353] &lt;inf&gt; transport: Published message: \"Hello MQTT! Current uptime is: 215285\" on topic: \"359404230074347/my/publish/topic\"\n%MDMEV: PRACH CE-LEVEL 0\n...\n[00:19:00.321,899] &lt;inf&gt; transport: Published message: \"Hello MQTT! Current uptime is: 1140311\" on topic: \"359404230074347/my/publish/topic\"\n%MDMEV: PRACH CE-LEVEL 0\n+CSCON: 1\n+CSCON: 0\n%MDMEV: PRACH CE-LEVEL 0\n+CSCON: 1\n[00:19:26.168,121] &lt;inf&gt; transport: Received payload: Hello from MQTTX! on topic: 359404230074347/my/subscribe/topic\n[00:19:30.233,001] &lt;inf&gt; transport: Received payload: Hello from MQTTX! on topic: 359404230074347/my/subscribe/topic\n+CSCON: 0\n...\n</code></pre> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\n[00:00:00.344,024] &lt;inf&gt; network: Bringing network interface up and connecting to the network\n+CGEV: EXCE STATUS 0\n%MDMEV: SEARCH STATUS 1\n+CEREG: 2,\"1D28\",\"0AC2CF3F\",9\n%MDMEV: PRACH CE-LEVEL 0\n+CSCON: 1\n+CGEV: ME PDN ACT 0,0\n+CNEC_ESM: 50,0\n%MDMEV: SEARCH STATUS 2\n+CEREG: 1,\"1D28\",\"0AC2CF3F\",9,,,\"00100001\",\"00000110\"\n[00:01:21.760,620] &lt;inf&gt; network: Network connectivity established\n[00:01:30.966,186] &lt;inf&gt; transport: Connected to MQTT broker\n[00:01:30.966,217] &lt;inf&gt; transport: Hostname: test.mosquitto.org\n[00:01:30.966,278] &lt;inf&gt; transport: Client ID: 359404230074347\n[00:01:30.966,278] &lt;inf&gt; transport: Port: 8883\n[00:01:30.966,308] &lt;inf&gt; transport: TLS: Yes\n[00:01:30.966,369] &lt;inf&gt; transport: Subscribing to: 359404230074347/my/subscribe/topic\n[00:01:31.401,245] &lt;inf&gt; transport: Subscribed to topic 359404230074347/my/subscribe/topic\n+CSCON: 0\n[00:02:00.352,905] &lt;inf&gt; transport: Published message: \"Hello MQTT! Current uptime is: 120345\" on topic: \"359404230074347/my/publish/topic\"\n%MDMEV: PRACH CE-LEVEL 0\n+CSCON: 1\n[00:02:19.722,869] &lt;inf&gt; transport: Published message: \"Hello MQTT! Current uptime is: 139721\" on topic: \"359404230074347/my/publish/topic\"\n[00:02:26.478,454] &lt;inf&gt; transport: Published message: \"Hello MQTT! Current uptime is: 146476\" on topic: \"359404230074347/my/publish/topic\"\n[00:02:30.345,581] &lt;inf&gt; transport: Received payload: Hello from MQTTX! on topic: 359404230074347/my/subscribe/topic\n[00:02:33.788,696] &lt;inf&gt; transport: Received payload: Hello from MQTTX! on topic: 359404230074347/my/subscribe/topic\n...\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/nrf_cloud_multi_service/","title":"nRF Cloud Multi-service","text":"<p>The nRF Cloud Multi-service sample is a minimal, error tolerant, integrated demonstration of the nRF Cloud, Location, and AT Host libraries.</p> <p>It demonstrates how you can integrate Firmware-Over-The-Air (FOTA), Location Services, Alert and Log Services, periodic sensor sampling, and more in your nRF Cloud-enabled application.</p> <p>It also demonstrates how to build connected, error-tolerant applications without worrying about physical-level specifics using Zephyr\u2019s <code>conn_mgr</code>.</p> <p>Refer to the nRF Connect SDK's nRF Cloud multi-service Documentation for more details.</p>"},{"location":"guides/ncs/samples/nrf_cloud_multi_service/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/nrf_cloud_multi_service/#dont-have-an-nrf-cloud-account","title":"Don't have an nRF Cloud account?","text":"<p>To connect your device and use nRF Cloud services, you must create an nRF Cloud account:</p> <ol> <li>Go to the nRF Cloud portal and click Register.</li> <li>Enter your email address and choose a password.</li> <li>Click Create Account.</li> <li> <p>Check for a verification email from nRF Cloud.</p> <p>Tip</p> <p>If you do not see the verification email, check your junk mail folder for an email from <code>no-reply@verificationemail.com</code>.</p> </li> <li> <p>Copy the six-digit verification code and paste it into the registration dialog box.</p> <p>Tip</p> <p>If you accidentally closed the registration dialog box, repeat Step 1 and click Already have a code?. Enter your email address and verification code.</p> </li> </ol> <p>You can now log in to the nRF Cloud portal with your email and password. After logging in, you can see the Dashboard view that displays your device count and service usage.</p>"},{"location":"guides/ncs/samples/nrf_cloud_multi_service/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/nrf_cloud_multi_service/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the nRF Cloud Multi-service sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/nrf_cloud_multi_service -- -DEXTRA_CONF_FILE=\"overlay-http_nrf_provisioning.conf\"\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/nrf_cloud_multi_service/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/nrf_cloud_multi_service/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Once the device is provisioned and connected, you should see the output, similar to what is shown in the following:</p> Terminal<pre><code>*** Booting My Application v2.1.0-dev-3a25855215a2 ***\n*** Using nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nI: Starting bootloader\nI: Primary image: magic=bad, swap_type=0x1, copy_done=0x2, image_ok=0x2\nI: Secondary image: magic=unset, swap_type=0x1, copy_done=0x3, image_ok=0x3\nI: Boot source: none\nI: Image index: 0, Swap type: none\nI: Bootloader chainload address offset: 0x10000\nAll pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\nTF-M Float ABI: Hard\nLazy stacking enabled\n\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\n[00:00:00.256,439] &lt;inf&gt; main: nRF Cloud multi-service sample has started, version: 1.0.0, protocol: MQTT\n[00:00:00.256,469] &lt;inf&gt; application: Reset reason: 0x10001\n[00:00:00.256,591] &lt;inf&gt; cloud_connection: Enabling connectivity...\n[00:00:00.585,540] &lt;inf&gt; cloud_connection: Setting up nRF Cloud library...\n[00:00:00.678,619] &lt;inf&gt; nrf_cloud_info: Device ID: 5034474b-3731-40ab-809f-152c5c11a9a5\n[00:00:00.679,107] &lt;inf&gt; nrf_cloud_info: IMEI:      359404230074347\n[00:00:00.764,770] &lt;inf&gt; nrf_cloud_info: UUID:      5034474b-3731-40ab-809f-152c5c11a9a5\n[00:00:00.765,167] &lt;inf&gt; nrf_cloud_info: Modem FW:  mfw_nrf91x1_2.0.2\n[00:00:00.765,197] &lt;inf&gt; nrf_cloud_info: Protocol:          MQTT\n[00:00:00.765,228] &lt;inf&gt; nrf_cloud_info: Download protocol: HTTPS\n[00:00:00.765,258] &lt;inf&gt; nrf_cloud_info: Sec tag:           16842753\n[00:00:00.765,289] &lt;inf&gt; nrf_cloud_info: Host name:         mqtt.nrfcloud.com\n[00:00:01.164,154] &lt;inf&gt; nrf_cloud_credentials: Sec Tag: 16842753; CA: Yes, Client Cert: Yes, Private Key: Yes\n[00:00:01.164,245] &lt;inf&gt; nrf_cloud_credentials: CA Size: 1792, AWS: Likely, CoAP: Likely\n[00:00:01.164,245] &lt;inf&gt; cloud_connection: Waiting for network ready...\n[00:01:24.932,098] &lt;inf&gt; cloud_connection: Network connectivity gained!\n[00:01:25.932,312] &lt;inf&gt; cloud_provisioning: Initializing the nRF Provisioning library...\n[00:01:25.932,861] &lt;inf&gt; cloud_connection: Network is ready\n[00:01:25.973,968] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 5s seconds\n[00:01:30.974,060] &lt;inf&gt; cloud_provisioning: Provisioning is active.\n[00:01:31.079,467] &lt;inf&gt; nrf_provisioning_http: Requesting commands\n[00:01:43.445,434] &lt;inf&gt; nrf_provisioning_http: Connected\n[00:01:43.445,465] &lt;inf&gt; nrf_provisioning_http: No more commands to process on server side\n[00:01:43.448,242] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 1800s seconds\n[00:01:48.445,556] &lt;inf&gt; cloud_provisioning: Provisioning is idle.\n[00:01:48.445,648] &lt;inf&gt; cloud_connection: Connecting to nRF Cloud\n[00:01:59.275,146] &lt;inf&gt; cloud_connection: Connected to nRF Cloud\n[00:02:02.058,624] &lt;inf&gt; shadow_config: Sending reported configuration\n[00:02:08.892,120] &lt;inf&gt; application: Waiting for modem to determine current date and time\n[00:02:08.892,181] &lt;inf&gt; application: Current date and time determined\n[00:02:08.892,211] &lt;inf&gt; nrf_cloud_log: Changing cloud logging enabled to:1\n[00:02:08.893,371] &lt;inf&gt; cloud_connection: Reducing provisioning check interval to 30 minutes\n[00:02:08.893,432] &lt;inf&gt; nrf_cloud_info: Team ID:   c9bd4aa8-a7e4-4cf1-a273-831d3700c24a\n[00:02:08.903,137] &lt;inf&gt; application: Temperature is 24 degrees C\n[00:02:08.903,961] &lt;inf&gt; nrf_cloud_pgps: Storage base:0xEB000, size:86016\n[00:02:08.908,996] &lt;inf&gt; nrf_cloud_pgps: Checking P-GPS header: Schema version:1, type:10, num:1, count:42\n[00:02:08.908,996] &lt;inf&gt; nrf_cloud_pgps:   size:2006, period (minutes):240, GPS day:16432, GPS time:21600\n[00:02:08.909,027] &lt;inf&gt; nrf_cloud_pgps: Checking stored P-GPS data; count:42, period_min:240\n[00:02:08.909,179] &lt;err&gt; nrf_cloud_pgps: prediction idx:26, ofs:0xf8000, out of expected time range; day:448, time:4278190335\n[00:02:08.909,210] &lt;err&gt; nrf_cloud_pgps: prediction idx:27, ofs:0xf8800, out of expected time range; day:65535, time:4294967295\n[00:02:08.909,240] &lt;err&gt; nrf_cloud_pgps: prediction idx:28, ofs:0xf9000, out of expected time range; day:65535, time:4294967295\n[00:02:08.909,240] &lt;err&gt; nrf_cloud_pgps: prediction idx:29, ofs:0xf9800, out of expected time range; day:65535, time:4294967295\n[00:02:08.909,515] &lt;wrn&gt; nrf_cloud_pgps: Prediction num:26 missing\n[00:02:08.909,545] &lt;inf&gt; nrf_cloud_pgps: Checking if P-GPS data is expired...\n[00:02:08.909,576] &lt;wrn&gt; nrf_cloud_pgps: Data expired!\n[00:02:08.909,576] &lt;err&gt; nrf_cloud_pgps: Find prediction returned err: -116\n[00:02:08.909,606] &lt;wrn&gt; nrf_cloud_pgps: Requesting predictions...\n[00:02:08.912,811] &lt;inf&gt; nrf_cloud_pgps: Requesting 42 predictions...\n[00:02:08.962,188] &lt;inf&gt; nrf_cloud_pgps: Searching for prediction\n[00:02:08.962,219] &lt;wrn&gt; nrf_cloud_pgps: Data expired!\n[00:02:08.965,332] &lt;inf&gt; nrf_cloud_pgps: Requesting 42 predictions...\n[00:02:13.011,962] &lt;inf&gt; nrf_cloud_pgps: Searching for prediction\n[00:02:13.012,023] &lt;wrn&gt; nrf_cloud_pgps: Data expired!\n[00:02:13.014,221] &lt;inf&gt; nrf_cloud_pgps: Requesting 42 predictions...\n[00:02:15.148,498] &lt;inf&gt; downloader: Setting up TLS credentials, sec tag count 1\n[00:02:15.148,620] &lt;inf&gt; downloader: Connecting to 2600:9000:25f2:b400:3:e9a6:59c0:93a1\n[00:02:15.149,322] &lt;inf&gt; downloader: Failed to connect on IPv6 (err -118), attempting IPv4\n[00:02:15.251,892] &lt;err&gt; nrf_cloud_pgps: Ignoring packet (https://pgps.nrfcloud.com, public/16473-28800_16480-14400.bin); P-GPS response already received.\n[00:02:15.251,922] &lt;err&gt; nrf_cloud_fsm: Error processing P-GPS data: -22\n[00:02:16.043,945] &lt;err&gt; nrf_cloud_pgps: Ignoring packet (https://pgps.nrfcloud.com, public/16473-28800_16480-14400.bin); P-GPS response already received.\n[00:02:16.043,945] &lt;err&gt; nrf_cloud_fsm: Error processing P-GPS data: -22\n[00:02:16.305,389] &lt;inf&gt; downloader: Setting up TLS credentials, sec tag count 1\n[00:02:16.305,511] &lt;inf&gt; downloader: Connecting to 18.173.121.51\n[00:02:33.050,354] &lt;inf&gt; downloader: Downloaded 1394/84268 bytes (1%)\n[00:02:33.050,384] &lt;inf&gt; nrf_cloud_pgps: Checking P-GPS header: Schema version:1, type:10, num:1, count:42\n[00:02:33.050,415] &lt;inf&gt; nrf_cloud_pgps:   size:2006, period (minutes):240, GPS day:16473, GPS time:28800\n[00:02:33.050,476] &lt;inf&gt; nrf_cloud_pgps: pgps_header: Schema version:1, type:10, num:1, count:42\n[00:02:33.050,476] &lt;inf&gt; nrf_cloud_pgps:   size:2006, period (minutes):240, GPS day:16473, GPS time:28800\n[00:02:33.052,398] &lt;inf&gt; downloader: Downloaded 1500/84268 bytes (1%)\n[00:02:35.137,390] &lt;inf&gt; downloader: Downloaded 2884/84268 bytes (3%)\n[00:02:35.137,512] &lt;inf&gt; nrf_cloud_pgps: Storing prediction num:0 idx:0 for gps sec:1423296000\n...\n[00:05:51.609,771] &lt;inf&gt; downloader: Downloaded 82500/84268 bytes (97%)\n[00:05:54.064,147] &lt;inf&gt; downloader: Downloaded 83880/84268 bytes (99%)\n[00:05:54.064,453] &lt;inf&gt; downloader: Downloaded 84000/84268 bytes (99%)\n[00:05:55.836,975] &lt;inf&gt; downloader: Downloaded 84268/84268 bytes (100%)\n[00:05:55.837,066] &lt;inf&gt; nrf_cloud_pgps: Storing prediction num:41 idx:41 for gps sec:1423886400\n[00:05:55.967,864] &lt;inf&gt; nrf_cloud_pgps: All P-GPS data received. Done.\n[00:05:55.967,926] &lt;inf&gt; nrf_cloud_pgps: Not time to find next prediction yet.\n[00:05:55.967,987] &lt;inf&gt; downloader: Download complete\n[00:06:08.903,289] &lt;inf&gt; application: Temperature is 23 degrees C\n...\n</code></pre> </li> <li> <p>Press USR/P25 button to send an alert message to nRF Cloud.</p> </li> <li> <p>Explore the device\u2019s page to see more features of nRF Cloud, such as Device Information, Device Data, Terminal, Temperature and Device Alerts, etc.</p> <p></p> </li> </ol>"},{"location":"guides/ncs/samples/nrf_cloud_rest_device_message/","title":"nRF Cloud REST Device Message","text":""},{"location":"guides/ncs/samples/nrf_cloud_rest_device_message/#overview","title":"Overview","text":"<p>The nRF Cloud REST Device Message sample demonstrates how to use the nRF Cloud REST API to send Device Messages using the <code>SendDeviceMessage</code> REST endpoint. Every button press sends a message to nRF Cloud.</p> <p>It also demonstrates use of the nRF Cloud Alert and the nRF Cloud Log libraries. The sample sends an alert when the device first comes online. It also sends a log message indicating the sample version, as well as when the button is pressed.</p> <p>You can also configure the sample to use the nRF Cloud Provisioning Service with the nRF Cloud device provisioning library.</p>"},{"location":"guides/ncs/samples/nrf_cloud_rest_device_message/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/nrf_cloud_rest_device_message/#dont-have-an-nrf-cloud-account","title":"Don't have an nRF Cloud account?","text":"<p>To connect your device and use nRF Cloud services, you must create an nRF Cloud account:</p> <ol> <li>Go to the nRF Cloud portal and click Register.</li> <li>Enter your email address and choose a password.</li> <li>Click Create Account.</li> <li> <p>Check for a verification email from nRF Cloud.</p> <p>Tip</p> <p>If you do not see the verification email, check your junk mail folder for an email from <code>no-reply@verificationemail.com</code>.</p> </li> <li> <p>Copy the six-digit verification code and paste it into the registration dialog box.</p> <p>Tip</p> <p>If you accidentally closed the registration dialog box, repeat Step 1 and click Already have a code?. Enter your email address and verification code.</p> </li> </ol> <p>You can now log in to the nRF Cloud portal with your email and password. After logging in, you can see the Dashboard view that displays your device count and service usage.</p>"},{"location":"guides/ncs/samples/nrf_cloud_rest_device_message/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/nrf_cloud_rest_device_message/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the nRF Cloud REST Device Message sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/nrf_cloud_rest_device_message -- -DEXTRA_CONF_FILE=overlay-nrf_provisioning.conf\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/nrf_cloud_rest_device_message/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/nrf_cloud_rest_device_message/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Wait for the LTE link to be established. If the device is not yet claimed or properly provisioned on the nRF Cloud, you may experience errors:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\nTF-M Float ABI: Hard\nLazy stacking enabled\n\n[00:00:00.636,322] &lt;inf&gt; nrf_cloud_rest_device_message: Waiting for network...\n[00:01:23.915,985] &lt;inf&gt; nrf_cloud_rest_device_message: Connected to LTE\n[00:01:23.925,292] &lt;inf&gt; nrf_cloud_rest_device_message: Waiting for modem to acquire network time...\n[00:01:26.937,652] &lt;inf&gt; nrf_cloud_rest_device_message: Network time obtained\n[00:01:26.947,418] &lt;inf&gt; nrf_cloud_log: Changing cloud logging enabled to:1\n[00:01:26.957,000] &lt;inf&gt; nrf_cloud_rest_device_message: Initializing the nRF Provisioning library...\n[00:01:27.005,828] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 5s seconds\n[00:01:27.120,697] &lt;inf&gt; nrf_cloud_credentials: Sec Tag: 16842753; CA: Yes, Client Cert: Yes, Private Key: Yes\n[00:01:27.133,300] &lt;inf&gt; nrf_cloud_credentials: CA Size: 1792, AWS: Likely, CoAP: Likely\n[00:01:27.143,981] &lt;inf&gt; nrf_cloud_rest_device_message: nRF Cloud credentials detected\n[00:01:27.155,487] &lt;inf&gt; nrf_cloud_info: Device ID: 5034474b-3731-40ab-809f-152c5c11a9a5\n[00:01:27.166,656] &lt;inf&gt; nrf_cloud_info: IMEI:      359404230074347\n[00:01:27.280,883] &lt;inf&gt; nrf_cloud_info: UUID:      5034474b-3731-40ab-809f-152c5c11a9a5\n[00:01:27.292,053] &lt;inf&gt; nrf_cloud_info: Modem FW:  mfw_nrf91x1_2.0.2\n[00:01:27.301,086] &lt;inf&gt; nrf_cloud_info: Protocol:          REST\n[00:01:27.309,692] &lt;inf&gt; nrf_cloud_info: Download protocol: HTTPS\n[00:01:27.318,389] &lt;inf&gt; nrf_cloud_info: Sec tag:           16842753\n[00:01:27.327,362] &lt;inf&gt; nrf_cloud_info: Host name:         api.nrfcloud.com\n[00:01:32.017,303] &lt;inf&gt; nrf_cloud_rest_device_message: Provisioning started\n[00:01:32.131,286] &lt;inf&gt; nrf_provisioning_http: Requesting commands\n[00:01:40.804,901] &lt;inf&gt; nrf_cloud_rest_device_message: Sending message:'{\"sample_message\":\"Hello World, from the REST Device Message Sample! Message ID: 1739250022860\"}'\n[00:01:41.973,175] &lt;inf&gt; nrf_provisioning_http: Connected\n[00:01:41.981,170] &lt;err&gt; nrf_provisioning_http: Device provided wrong auth credentials\n[00:01:41.991,943] &lt;inf&gt; nrf_cloud_rest_device_message: Provisioning stopped\n[00:01:42.001,586] &lt;wrn&gt; nrf_provisioning: Unauthorized access: device is not yet claimed.\n[00:01:42.012,695] &lt;err&gt; nrf_provisioning: Provisioning failed, error: -13\n[00:01:42.022,460] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 86402s seconds\n[00:01:42.242,370] &lt;inf&gt; nrf_cloud_rest_device_message: Message sent\n[00:01:42.251,342] &lt;inf&gt; nrf_cloud_rest_device_message: Sent Hello World message with ID: 1739250022860\nuart:~$\n</code></pre> </li> <li> <p>Type <code>nrf_provisioning token</code> command and press the Enter key Enter to get the device's attestation token.</p> </li> <li> <p>Log in to the nRF Cloud portal. Claim the board by performing the following steps:</p> <ol> <li>Select Security Services -&gt; Claimed Devices.</li> <li>Click the Claim Device button. A pop-up opens.</li> <li>Leave the default type Single selected.</li> <li>Paste the attestation token into the Claim Token field.</li> <li>Select Create new rule for onboarding to nRF Cloud so it is toggled on. This enables auto-onboarding and creates a rule that you can use later to onboard additional devices. Creating a rule also adds an associated provisioning group.</li> <li>Change the name of the rule, if desired.</li> <li>The default security tag for the nRF Cloud samples is <code>16842753</code>. Leave this default value as is for initial onboarding.</li> <li>Leave the default Root CA Certificates option All selected. This allows the device to use both CoAP and MQTT/REST to connect to nRF Cloud.</li> <li>The Device Management Groups, Supported Firmware Types, and Device Subtype fields are optional. You can leave them blank.</li> <li>Click the Create Rule and Claim Device button.</li> </ol> <p></p> <p>The device is now claimed and ready to use the nRF Cloud Provisioning Service. It appears in the Claimed Devices list in a provisioning group for the newly created rule.</p> </li> <li> <p>To enforce the connection to the provisioning service, press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Once the device is provisioned and connected, you should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\nTF-M Float ABI: Hard\nLazy stacking enabled\n\n[00:00:00.636,199] &lt;inf&gt; nrf_cloud_rest_device_message: Waiting for network...\n[00:01:25.119,812] &lt;inf&gt; nrf_cloud_rest_device_message: Connected to LTE\n[00:01:25.129,119] &lt;inf&gt; nrf_cloud_rest_device_message: Waiting for modem to acquire network time...\n[00:01:28.141,510] &lt;inf&gt; nrf_cloud_rest_device_message: Network time obtained\n[00:01:28.151,245] &lt;inf&gt; nrf_cloud_log: Changing cloud logging enabled to:1\n[00:01:28.160,797] &lt;inf&gt; nrf_cloud_rest_device_message: Initializing the nRF Provisioning library...\n[00:01:28.209,686] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 5s seconds\n[00:01:28.324,401] &lt;inf&gt; nrf_cloud_credentials: Sec Tag: 16842753; CA: Yes, Client Cert: Yes, Private Key: Yes\n[00:01:28.337,005] &lt;inf&gt; nrf_cloud_credentials: CA Size: 1792, AWS: Likely, CoAP: Likely\n[00:01:27.143,981] &lt;inf&gt; nrf_cloud_rest_device_message: nRF Cloud credentials detected\n[00:01:27.155,487] &lt;inf&gt; nrf_cloud_info: Device ID: 5034474b-3731-40ab-809f-152c5c11a9a5\n[00:01:28.370,330] &lt;inf&gt; nrf_cloud_info: IMEI:      359404230074347\n[00:01:28.484,375] &lt;inf&gt; nrf_cloud_info: UUID:      5034474b-3731-40ab-809f-152c5c11a9a5\n[00:01:28.495,483] &lt;inf&gt; nrf_cloud_info: Modem FW:  mfw_nrf91x1_2.0.2\n[00:01:28.504,516] &lt;inf&gt; nrf_cloud_info: Protocol:          REST\n[00:01:28.513,092] &lt;inf&gt; nrf_cloud_info: Download protocol: HTTPS\n[00:01:28.521,789] &lt;inf&gt; nrf_cloud_info: Sec tag:           16842753\n[00:01:28.530,731] &lt;inf&gt; nrf_cloud_info: Host name:         api.nrfcloud.com\n[00:01:33.221,130] &lt;inf&gt; nrf_cloud_rest_device_message: Provisioning started\n[00:01:33.333,007] &lt;inf&gt; nrf_provisioning_http: Requesting commands\n[00:01:37.018,554] &lt;inf&gt; nrf_cloud_rest_device_message: Sending message:'{\"sample_message\":\"Hello World, from the REST Device Message Sample! Message ID: 1739250637810\"}'\n[00:01:38.885,772] &lt;inf&gt; nrf_provisioning_http: Connected\n[00:01:38.896,850] &lt;inf&gt; nrf_provisioning_http: Processing commands\n[00:01:40.871,307] &lt;inf&gt; nrf_cloud_rest_device_message: Message sent\n[00:01:40.880,249] &lt;inf&gt; nrf_cloud_rest_device_message: Sent Hello World message with ID: 1739250637810\n[00:01:40.955,505] &lt;inf&gt; nrf_provisioning: Disconnected from network - provisioning paused\n[00:02:39.134,582] &lt;inf&gt; nrf_provisioning: Disconnected from network - provisioning paused\n[00:02:41.072,204] &lt;inf&gt; nrf_provisioning: Connected; home network - provisioning resumed\n[00:02:41.083,038] &lt;inf&gt; nrf_cloud_rest_device_message: Modem connection restored\n[00:02:41.093,109] &lt;inf&gt; nrf_cloud_rest_device_message: Waiting for modem to acquire network time...\n[00:02:44.105,712] &lt;inf&gt; nrf_cloud_rest_device_message: Network time obtained\n[00:02:44.115,661] &lt;inf&gt; nrf_provisioning_http: Sending response to server\n[00:02:51.306,182] &lt;inf&gt; nrf_provisioning_http: Requesting commands\n[00:02:53.337,402] &lt;inf&gt; nrf_provisioning_http: Connected\n[00:02:53.348,449] &lt;inf&gt; nrf_provisioning_http: Processing commands\n[00:02:53.422,943] &lt;inf&gt; nrf_provisioning: Disconnected from network - provisioning paused\n[00:03:46.309,051] &lt;inf&gt; nrf_provisioning: Disconnected from network - provisioning paused\n[00:03:48.354,522] &lt;inf&gt; nrf_provisioning: Connected; home network - provisioning resumed\n[00:03:48.365,356] &lt;inf&gt; nrf_cloud_rest_device_message: Modem connection restored\n[00:03:48.375,396] &lt;inf&gt; nrf_cloud_rest_device_message: Waiting for modem to acquire network time...\n[00:03:51.387,878] &lt;inf&gt; nrf_cloud_rest_device_message: Network time obtained\n[00:03:51.397,705] &lt;inf&gt; nrf_provisioning_http: Sending response to server\n[00:03:53.900,726] &lt;inf&gt; nrf_cloud_rest_device_message: Provisioning stopped\n[00:03:53.910,369] &lt;inf&gt; nrf_cloud_rest_device_message: Provisioning done, rebooting...\n[00:03:53.998,901] &lt;inf&gt; nrf_provisioning: Disconnected from network - provisioning paused\nuart:~$ All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\nTF-M Float ABI: Hard\nLazy stacking enabled\n\n[00:00:00.615,325] &lt;inf&gt; nrf_cloud_rest_device_message: Waiting for network...\n[00:01:25.739,044] &lt;inf&gt; nrf_cloud_rest_device_message: Connected to LTE\n[00:01:25.748,352] &lt;inf&gt; nrf_cloud_rest_device_message: Waiting for modem to acquire network time...\n[00:01:28.760,742] &lt;inf&gt; nrf_cloud_rest_device_message: Network time obtained\n[00:01:28.770,477] &lt;inf&gt; nrf_cloud_log: Changing cloud logging enabled to:1\n[00:01:28.780,029] &lt;inf&gt; nrf_cloud_rest_device_message: Initializing the nRF Provisioning library...\n[00:01:28.828,765] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 5s seconds\n[00:01:28.943,725] &lt;inf&gt; nrf_cloud_credentials: Sec Tag: 16842753; CA: Yes, Client Cert: Yes, Private Key: Yes\n[00:01:28.956,298] &lt;inf&gt; nrf_cloud_credentials: CA Size: 1792, AWS: Likely, CoAP: Likely\n[00:01:28.966,979] &lt;inf&gt; nrf_cloud_rest_device_message: nRF Cloud credentials detected\n[00:01:28.978,454] &lt;inf&gt; nrf_cloud_info: Device ID: 5034474b-3731-40ab-809f-152c5c11a9a5\n[00:01:28.989,624] &lt;inf&gt; nrf_cloud_info: IMEI:      359404230074347\n[00:01:29.103,851] &lt;inf&gt; nrf_cloud_info: UUID:      5034474b-3731-40ab-809f-152c5c11a9a5\n[00:01:29.115,081] &lt;inf&gt; nrf_cloud_info: Modem FW:  mfw_nrf91x1_2.0.2\n[00:01:29.124,114] &lt;inf&gt; nrf_cloud_info: Protocol:          REST\n[00:01:29.132,690] &lt;inf&gt; nrf_cloud_info: Download protocol: HTTPS\n[00:01:29.141,357] &lt;inf&gt; nrf_cloud_info: Sec tag:           16842753\n[00:01:29.150,299] &lt;inf&gt; nrf_cloud_info: Host name:         api.nrfcloud.com\n[00:01:33.840,332] &lt;inf&gt; nrf_cloud_rest_device_message: Provisioning started\n[00:01:33.956,298] &lt;inf&gt; nrf_provisioning_http: Requesting commands\n[00:01:35.709,075] &lt;inf&gt; nrf_cloud_rest_device_message: Sending message:'{\"sample_message\":\"Hello World, from the REST Device Message Sample! Message ID: 1739250870944\"}'\n[00:01:40.007,720] &lt;inf&gt; nrf_cloud_rest_device_message: Message sent\n[00:01:40.016,662] &lt;inf&gt; nrf_cloud_rest_device_message: Sent Hello World message with ID: 1739250870944\n[00:01:41.155,944] &lt;inf&gt; nrf_provisioning_http: Connected\n[00:01:41.163,940] &lt;inf&gt; nrf_provisioning_http: No more commands to process on server side\n[00:01:41.174,804] &lt;inf&gt; nrf_cloud_rest_device_message: Provisioning stopped\n[00:01:41.184,478] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 86400s seconds\nuart:~$\n</code></pre> </li> <li> <p>Press USR/P25 button to have a message sent to nRF Cloud:</p> Terminal<pre><code>[00:10:27.922,180] &lt;inf&gt; nrf_cloud_rest_device_message: Button 1 pressed\n[00:10:27.931,610] &lt;inf&gt; nrf_cloud_rest_device_message: Sending message:'{\"appId\":\"BUTTON\", \"messageType\":\"DATA\", \"data\":\"1\"}'\n[00:10:37.257,049] &lt;inf&gt; nrf_cloud_rest_device_message: Message sent\n</code></pre> </li> <li> <p>After the messages sent, verify that on the nRF Cloud: </p> <ol> <li>Select Device Management -&gt; Devices.</li> <li>Click the ID of the device you added.</li> <li>On the device\u2019s page, you should see the messages displayed on the Terminal.</li> </ol> <p></p> </li> </ol>"},{"location":"guides/ncs/samples/nrf_provisioning/","title":"nRF Cloud Device Provisioning","text":""},{"location":"guides/ncs/samples/nrf_provisioning/#overview","title":"Overview","text":"<p>The nRF Cloud Device Provisioning sample demonstrates how to use the nRF Cloud device provisioning service on the nRF9151 Connect Kit.</p> <p>The sample shows how the device performs the following actions:</p> <ul> <li>Connects to nRF Cloud Provisioning Service.</li> <li>Fetches available device-specific provisioning configuration.</li> <li>Decodes the commands.</li> <li>Acts on any AT commands, if available.</li> <li>Reports the results back to the server. In the case of an error, stops processing the commands at the first error and reports it back to server.</li> <li>Sends <code>FINISHED</code> response if all the previous commands are executed without errors provided and <code>FINISHED</code> is one of the set provisioning commands.</li> </ul>"},{"location":"guides/ncs/samples/nrf_provisioning/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/nrf_provisioning/#dont-have-an-nrf-cloud-account","title":"Don't have an nRF Cloud account?","text":"<p>To connect your device and use nRF Cloud services, you must create an nRF Cloud account:</p> <ol> <li>Go to the nRF Cloud portal and click Register.</li> <li>Enter your email address and choose a password.</li> <li>Click Create Account.</li> <li> <p>Check for a verification email from nRF Cloud.</p> <p>Tip</p> <p>If you do not see the verification email, check your junk mail folder for an email from <code>no-reply@verificationemail.com</code>.</p> </li> <li> <p>Copy the six-digit verification code and paste it into the registration dialog box.</p> <p>Tip</p> <p>If you accidentally closed the registration dialog box, repeat Step 1 and click Already have a code?. Enter your email address and verification code.</p> </li> </ol> <p>You can now log in to the nRF Cloud portal with your email and password. After logging in, you can see the Dashboard view that displays your device count and service usage.</p>"},{"location":"guides/ncs/samples/nrf_provisioning/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/nrf_provisioning/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the nRF Cloud Device Provisioning sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/nrf_provisioning\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/nrf_provisioning/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/nrf_provisioning/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Wait for the LTE link to be established. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\nTF-M Float ABI: Hard\nLazy stacking enabled\n\n[00:00:00.541,412] &lt;inf&gt; nrf_provisioning_sample: Establishing LTE link ...\n[00:01:26.375,061] &lt;inf&gt; nrf_provisioning: Provisioning new certificate\nuart:~$\n[00:02:21.829,528] &lt;inf&gt; nrf_provisioning_sample: Modem connection restored\n[00:02:21.839,080] &lt;inf&gt; nrf_provisioning_sample: Waiting for modem to acquire network time...\n[00:02:24.850,982] &lt;inf&gt; nrf_provisioning_sample: Network time obtained\n[00:02:25.033,386] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 3s seconds\n[00:02:28.044,403] &lt;inf&gt; nrf_provisioning_sample: Provisioning started\n[00:02:28.159,698] &lt;inf&gt; nrf_provisioning_http: Requesting commands\n[00:02:36.961,242] &lt;inf&gt; nrf_provisioning_http: Connected\n[00:02:36.969,207] &lt;inf&gt; nrf_provisioning_http: No more commands to process on server side\n[00:02:36.980,072] &lt;inf&gt; nrf_provisioning_sample: Provisioning stopped\n[00:02:36.989,227] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 86402s seconds\nuart:~$\n</code></pre> </li> <li> <p>Type <code>nrf_provisioning token</code> command and press the Enter key Enter to get the device\u2019s attestation token.</p> </li> <li> <p>Log in to the nRF Cloud portal. Claim the board by performing the following steps:</p> <ol> <li>Select Security Services -&gt; Claimed Devices.</li> <li>Click the Claim Device button. A pop-up opens.</li> <li>Leave the default type Single selected.</li> <li>Paste the attestation token into the Claim Token field.</li> <li>Select Create new rule for onboarding to nRF Cloud so it is toggled on. This enables auto-onboarding and creates a rule that you can use later to onboard additional devices. Creating a rule also adds an associated provisioning group.</li> <li>Change the name of the rule, if desired.</li> <li>The default security tag for the nRF Cloud samples is <code>16842753</code>. Leave this default value as is for initial onboarding.</li> <li>Leave the default Root CA Certificates option All selected. This allows the device to use both CoAP and MQTT/REST to connect to nRF Cloud.</li> <li>The Device Management Groups, Supported Firmware Types, and Device Subtype fields are optional. You can leave them blank.</li> <li>Click the Create Rule and Claim Device button.</li> </ol> <p></p> <p>The device is now claimed and ready to use the nRF Cloud Provisioning Service. It appears in the Claimed Devices list in a provisioning group for the newly created rule.</p> </li> <li> <p>To enforce the connection to the provisioning service, press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Verify in the terminal that the device checks for provisioning commands and runs them. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\nTF-M Float ABI: Hard\nLazy stacking enabled\n\n[00:00:00.541,442] &lt;inf&gt; nrf_provisioning_sample: Establishing LTE link ...\n[00:01:21.382,537] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 3s seconds\n[00:01:24.393,554] &lt;inf&gt; nrf_provisioning_sample: Provisioning started\n[00:01:24.507,537] &lt;inf&gt; nrf_provisioning_http: Requesting commands\n[00:01:32.932,800] &lt;inf&gt; nrf_provisioning_http: Connected\n[00:01:32.943,847] &lt;inf&gt; nrf_provisioning_http: Processing commands\n[00:01:33.546,997] &lt;inf&gt; nrf_provisioning: Disconnected from network - provisioning paused\n[00:02:26.529,174] &lt;inf&gt; nrf_provisioning: Disconnected from network - provisioning paused\n[00:02:29.311,004] &lt;inf&gt; nrf_provisioning: Connected; home network - provisioning resumed\n[00:02:29.321,838] &lt;inf&gt; nrf_provisioning_sample: Modem connection restored\n[00:02:29.331,390] &lt;inf&gt; nrf_provisioning_sample: Waiting for modem to acquire network time...\n[00:02:32.343,444] &lt;inf&gt; nrf_provisioning_sample: Network time obtained\n[00:02:32.352,874] &lt;inf&gt; nrf_provisioning_http: Sending response to server\n[00:02:35.658,569] &lt;inf&gt; nrf_provisioning_http: Requesting commands\n[00:02:38.420,654] &lt;inf&gt; nrf_provisioning_http: Connected\n[00:02:38.431,701] &lt;inf&gt; nrf_provisioning_http: Processing commands\n[00:02:39.059,326] &lt;inf&gt; nrf_provisioning: Disconnected from network - provisioning paused\n[00:03:31.971,496] &lt;inf&gt; nrf_provisioning: Disconnected from network - provisioning paused\n[00:03:36.402,374] &lt;inf&gt; nrf_provisioning: Connected; home network - provisioning resumed\n[00:03:36.413,208] &lt;inf&gt; nrf_provisioning_sample: Modem connection restored\n[00:03:36.422,729] &lt;inf&gt; nrf_provisioning_sample: Waiting for modem to acquire network time...\n[00:03:39.434,692] &lt;inf&gt; nrf_provisioning_sample: Network time obtained\n[00:03:39.443,969] &lt;inf&gt; nrf_provisioning_http: Sending response to server\n[00:03:42.438,201] &lt;inf&gt; nrf_provisioning_sample: Provisioning stopped\n[00:03:42.447,296] &lt;inf&gt; nrf_provisioning_sample: Provisioning done, rebooting...\n[00:03:42.801,940] &lt;inf&gt; nrf_provisioning: Disconnected from network - provisioning paused\nuart:~$ All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\nTF-M Float ABI: Hard\nLazy stacking enabled\n\n[00:00:00.520,874] &lt;inf&gt; nrf_provisioning_sample: Establishing LTE link ...\n[00:01:23.054,931] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 3s seconds\n[00:01:26.065,979] &lt;inf&gt; nrf_provisioning_sample: Provisioning started\n[00:01:26.179,962] &lt;inf&gt; nrf_provisioning_http: Requesting commands\n[00:01:34.705,780] &lt;inf&gt; nrf_provisioning_http: Connected\n[00:01:34.713,775] &lt;inf&gt; nrf_provisioning_http: No more commands to process on server side\n[00:01:34.724,609] &lt;inf&gt; nrf_provisioning_sample: Provisioning stopped\n[00:01:34.733,764] &lt;inf&gt; nrf_provisioning: Checking for provisioning commands in 86400s seconds\nuart:~$\n</code></pre> </li> <li> <p>After the device finishes processing provisioning commands, the device status is now shown as <code>PROVISIONED</code>.</p> <p></p> </li> </ol>"},{"location":"guides/ncs/samples/shell/","title":"Shell","text":""},{"location":"guides/ncs/samples/shell/#overview","title":"Overview","text":"<p>The Shell sample shows you how to register a custom command into the Zephyr Shell. The following custom command will be registered:</p> <ul> <li><code>version</code>: Show the kernel version.</li> </ul>"},{"location":"guides/ncs/samples/shell/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/shell/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the Shell sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151 samples/shell\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Tip</p> <p>You can also build this sample for the <code>nrf9151_connectkit/nrf9151/ns</code> target. In such a case, the sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/shell\n</code></pre> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/shell/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Connect the nRF9151 Connect Kit to the computer with a USB-C cable:</p> <p></p> <p>Then flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/shell/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Once the sample starts running, you should see the following output:</p> Terminal<pre><code>*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nuart:~$\n</code></pre> </li> <li> <p>Type <code>version</code> command and press the Enter key Enter . You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>uart:~$ version\nZephyr version 3.7.99\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/tls_cipher_suites/","title":"TLS Cipher Suites","text":""},{"location":"guides/ncs/samples/tls_cipher_suites/#overview","title":"Overview","text":"<p>The TLS Cipher Suites sample demonstrates a minimal implementation of a client application that attempts to connect to a host by trying different Transport Layer Security (TLS) cipher suites. This sample shows the cipher suites and lists them as supported or not supported by the host, and provides a summary of the support.</p>"},{"location":"guides/ncs/samples/tls_cipher_suites/#how-it-works","title":"How it works","text":"<p>The sample first initializes the Modem library and AT communications. Next, it provisions a root CA certificate to the modem using the Modem key management library. Provisioning must be done before connecting to the LTE network because the certificates can only be provisioned when the device is not connected.</p> <p>The sample then iterates through a list of TLS cipher suites, attempting connection to the host with each one of them. The sample connects successfully to the host (<code>makerdiary.com</code>) with the cipher suites that are supported by the host, while unsupported cipher suites cause a connection failure.</p> <p>Finally, the sample provides a summary of the cipher suites that are supported and not supported by the host, <code>makerdiary.com</code>.</p> <p>The sample connects to <code>makerdiary.com</code>, which requires an X.509 certificate. This certificate is provided in the <code>ciphersuites/cert</code> folder. The certificate is automatically converted to a HEX format in the <code>CMakeLists.txt</code> file. The generated <code>.inc</code> file is then included in the code, where it is provisioned to the modem.</p>"},{"location":"guides/ncs/samples/tls_cipher_suites/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/tls_cipher_suites/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/tls_cipher_suites/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the [Modem Trace Backend] sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/ciphersuites\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/tls_cipher_suites/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/tls_cipher_suites/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nTLS Ciphersuites sample started\nCertificate match\nWaiting for network.. OK\nTrying all ciphersuites to find out which ones are supported...\nTrying ciphersuite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256\nConnecting to makerdiary.com... Connected.\nTrying ciphersuite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384\nConnecting to makerdiary.com... Connected.\nTrying ciphersuite: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA\nConnecting to makerdiary.com... connect() failed, err: 111, Connection refused\nTrying ciphersuite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256\nConnecting to makerdiary.com... Connected.\nTrying ciphersuite: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA\nConnecting to makerdiary.com... connect() failed, err: 111, Connection refused\nTrying ciphersuite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\nConnecting to makerdiary.com... connect() failed, err: 111, Connection refused\nTrying ciphersuite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256\nConnecting to makerdiary.com... connect() failed, err: 111, Connection refused\nTrying ciphersuite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\nConnecting to makerdiary.com... connect() failed, err: 111, Connection refused\nTrying ciphersuite: TLS_PSK_WITH_AES_256_CBC_SHA\nConnecting to makerdiary.com... connect() failed, err: 111, Connection refused\nTryin ciphersuite: TLS_PSK_WITH_AES_128_CBC_SHA256\nConnecting to makerdiary.com... connect() failed, err: 111, Connection refused\nTrying ciphersuite: TLS_PSK_WITH_AES_128_CBC_SHA\nConnecting to makerdiary.com... connect() failed, err: 111, Connection refused\nTrying ciphersuite: TLS_PSK_WITH_AES_128_CCM_8\nConnecting to makerdiary.com... connect() failed, err: 111, Connection refused\nTrying ciphersuite: TLS_EMPTY_RENEGOTIATIONINFO_SCSV\nConnecting to makerdiary.com... connect() failed, err: 111, Connection refused\n\nCiphersuite support summary for host `makerdiary.com`:\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: Yes\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: Yes\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: No\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: Yes\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: No\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: No\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: No\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: No\nTLS_PSK_WITH_AES_256_CBC_SHA: No\nTLS_PSK_WITH_AES_128_CBC_SHA256: No\nTLS_PSK_WITH_AES_128_CBC_SHA: No\nTLS_PSK_WITH_AES_128_CCM_8: No\nTLS_EMPTY_RENEGOTIATIONINFO_SCSV: No\n\nFinished.\n</code></pre> </li> </ol>"},{"location":"guides/ncs/samples/udp/","title":"UDP","text":""},{"location":"guides/ncs/samples/udp/#overview","title":"Overview","text":"<p>The UDP sample demonstrates how to perform sequential transmissions of UDP packets to a UDP server.</p> <p>The sample connects to an LTE network using the Connection Manager. Once connected, it sets up a UDP socket and continuously transmits data over the socket to a configurable IP address and port number.</p>"},{"location":"guides/ncs/samples/udp/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x nano-SIM card with LTE-M or NB-IoT support</li> <li>1x U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna (included in the box)</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/ncs/samples/udp/#set-up-your-board","title":"Set up your board","text":"<ol> <li>Insert the nano-SIM card into the nano-SIM card slot.</li> <li>Attach the U.FL cabled LTE-M/NB-IoT/NR+ Flexible Antenna.</li> <li>Connect the nRF9151 Connect Kit to the computer with a USB-C cable.</li> </ol>"},{"location":"guides/ncs/samples/udp/#building-the-sample","title":"Building the sample","text":"<p>To build the sample, follow the instructions in Getting Started Guide to set up your preferred building environment.</p> <p>Use the following steps to build the UDP sample on the command line.</p> <ol> <li> <p>Open a terminal window.</p> </li> <li> <p>Go to <code>NCS-Project/nrf9151-connectkit</code> repository cloned in the Getting Started Guide.</p> </li> <li> <p>Build the sample using the <code>west build</code> command, specifying the board (following the <code>-b</code> option) as <code>nrf9151_connectkit/nrf9151/ns</code>.</p> <pre><code>west build -p always -b nrf9151_connectkit/nrf9151/ns samples/udp\n</code></pre> <p>The <code>-p</code> always option forces a pristine build, and is recommended for new users. Users may also use the <code>-p auto</code> option, which will use heuristics to determine if a pristine build is required, such as when building another sample.</p> <p>Note</p> <p>This sample has Cortex-M Security Extensions (CMSE) enabled and separates the firmware between Non-Secure Processing Environment (NSPE) and Secure Processing Environment (SPE). Because of this, it automatically includes the Trusted Firmware-M (TF-M).</p> </li> <li> <p>After building the sample successfully, the firmware with the name <code>merged.hex</code> can be found in the <code>build</code> directory.</p> </li> </ol>"},{"location":"guides/ncs/samples/udp/#flashing-the-firmware","title":"Flashing the firmware","text":"<p>Set up your board before flashing the firmware. You can flash the sample using <code>west flash</code>:</p> <pre><code>west flash\n</code></pre> <p>Tip</p> <p>In case you wonder, the <code>west flash</code> will execute the following command:</p> <pre><code>pyocd load --target nrf91 --frequency 4000000 build/merged.hex\n</code></pre>"},{"location":"guides/ncs/samples/udp/#testing","title":"Testing","text":"<p>After programming the sample, test it by performing the following steps:</p> <ol> <li> <p>Open up a serial terminal, specifying the correct serial port that your computer uses to communicate with the nRF9151 SiP:</p> WindowsmacOSUbuntu <ol> <li>Start PuTTY.</li> <li> <p>Configure the correct serial port and click Open:</p> <p></p> </li> </ol> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> <p>Open up a terminal and run:</p> <pre><code>screen &lt;serial-port-name&gt; 115200\n</code></pre> </li> <li> <p>Press the DFU/RST button to reset the nRF9151 SiP.</p> </li> <li> <p>Observe the output of the terminal. You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>All pins have been configured as non-secure\nBooting TF-M v2.1.0\n[Sec Thread] Secure image initializing!\n*** Booting nRF Connect SDK v2.9.99-98a5e50b9ac1 ***\n*** Using Zephyr OS v3.7.99-693769a5c735 ***\nUDP sample has started\nLTE cell changed: Cell ID: 225458507, Tracking area: 7459\nRAI configuration update: Cell ID: 225458507, MCC: 460, MNC: 0, AS-RAI: 0, CP-RAI: 1\nRRC mode: Connected\nNetwork registration status: Connected - home\nPSM parameter update: TAU: 3600 s, Active time: 0 s\nTransmitting UDP/IP payload of 38 bytes to the IP address 8.8.8.8, port number 2469\nRRC mode: Idle\n\nTransmitting UDP/IP payload of 38 bytes to the IP address 8.8.8.8, port number 2469\nRAI configuration update: Cell ID: 225458507, MCC: 460, MNC: 0, AS-RAI: 1, CP-RAI: 1\nRRC mode: Connected\nRRC mode: Idle\n...\n</code></pre> </li> </ol>"},{"location":"guides/programming/","title":"Programming Guide","text":"<p>The nRF9151 Connect Kit comes with an Interface MCU (nRF52820) which enables debug, programming as well as modem firmware update, no need for any external tools.</p> <p>In this guide, you will learn how to update the nRF9151 firmware including the modem firmware, and the Interface MCU Firmware.</p> <ul> <li> <p>Update the nRF9151 Firmware</p> </li> <li> <p>Update the Interface MCU Firmware</p> </li> </ul>"},{"location":"guides/programming/update-ifmcu-fw/","title":"Update the Interface MCU Firmware","text":""},{"location":"guides/programming/update-ifmcu-fw/#overview","title":"Overview","text":"<p>This guide describes how you can update the application firmware and bootloader of the Interface MCU on the nRF9151 Connect Kit.</p>"},{"location":"guides/programming/update-ifmcu-fw/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x USB-C Cable</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul>"},{"location":"guides/programming/update-ifmcu-fw/#update-the-application-firmware","title":"Update the application firmware","text":"<p>The application firmware is compatible with the UF2 Bootloader, so that you can easily update the firmware by just copying the .uf2-format file to the flash drive without using an external programmer.</p> <p>Tip</p> <p>The pre-built firmware will be published on GitHub Releases. Alternatively, you may build your own firmware by completing the steps in the Interface MCU Firmware documentation. </p> <p>To update the firmware, complete the following steps:</p> <ol> <li> <p>Push and hold the DFU/RST button and connect your board to the USB port of your computer. Release the DFU/RST button after your board is connected.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT. The RGB LED is breathing in red.</p> </li> <li> <p>Drag and drop .uf2-format file onto the UF2BOOT volume. The RGB LED blinks red rapidly during programming.</p> </li> <li> <p>The application starts running after the firmware programming is completed.</p> </li> </ol> <p>Note</p> <p>You may experience the following errors when copying the firmware to the UF2BOOT drive on macOS 14.5 or newer:</p> <p></p> Terminal<pre><code>$ cp build/ifmcu_firmware/zephyr/zephyr.uf2 /Volumes/UF2BOOT\ncp: /Volumes/UF2BOOT/zephyr.uf2: fcopyfile failed: Input/output error\ncp: /Volumes/UF2BOOT/zephyr.uf2: fchmod failed: No such file or directory\n</code></pre> <p>Currently you can ignore these errors as the firmware programming is completed and the application should work as expected.</p>"},{"location":"guides/programming/update-ifmcu-fw/#update-the-uf2-bootloader","title":"Update the UF2 Bootloader","text":"<p>The UF2 Bootloader is self-upgradable, and you can simply update the bootloader by just copying the .uf2-format file to the flash drive without using an external programmer.</p> <p>Tip</p> <p>The pre-built bootloader will be published on GitHub Releases with the name <code>update-nrf9151_connectkit_nrf52820_uf2boot-&lt;version&gt;.uf2</code>.</p> <p>To update the bootloader, complete the following steps:</p> <ol> <li> <p>Push and hold the DFU/RST button and connect your board to the USB port of your computer. Release the DFU/RST button after your board is connected.</p> </li> <li> <p>It will mount as a Mass Storage Device called UF2BOOT. The RGB LED is breathing in red.</p> </li> <li> <p>Open <code>INFO_UF2.TXT</code> in the UF2BOOT volume with a text editor, and check the current version of bootloader. The figure below shows we are running the <code>1.0.0</code> version.</p> <p></p> </li> <li> <p>Drag and drop a newer .uf2-format bootloader onto the UF2BOOT volume. The RGB LED blinks red rapidly during programming.</p> </li> <li> <p>The new bootloader starts running after the firmware programming is completed.</p> </li> <li>Re-enter the UF2 Bootloader mode, and verify the version printed in <code>INFO_UF2.TXT</code>.</li> </ol> <p>Note</p> <p>You may experience the following errors when copying the firmware to the UF2BOOT drive on macOS 14.5 or newer:</p> <p></p> Terminal<pre><code>$ cp build/ifmcu_firmware/zephyr/zephyr.uf2 /Volumes/UF2BOOT\ncp: /Volumes/UF2BOOT/zephyr.uf2: fcopyfile failed: Input/output error\ncp: /Volumes/UF2BOOT/zephyr.uf2: fchmod failed: No such file or directory\n</code></pre> <p>Currently you can ignore these errors as the firmware programming is completed and the application should work as expected.</p>"},{"location":"guides/programming/update-ifmcu-fw/#recovery-from-a-broken-uf2-bootloader","title":"Recovery from a broken UF2 Bootloader","text":"<p>If your device fails to enter the bootloader mode, you may need to perform a recovery from a broken UF2 bootloader. To re-program the UF2 Bootloader, an external debug probe is needed.</p> <p>Tip</p> <p>The pre-built bootloader will be published on GitHub Releases with the name <code>nrf9151_connectkit_nrf52820_uf2boot-&lt;version&gt;.hex</code>.</p> <p>The SWD port of Interface MCU (nRF52820) is exposed on the bottom of the board. Note that the signal voltage levels of SWD should match to VDD_GPIO.</p> <p>The following figure illustrates the SWD port of the Interface MCU (nRF52820):</p> <p></p>"},{"location":"guides/programming/update-nrf9151-fw/","title":"Update the nRF9151 Firmware","text":""},{"location":"guides/programming/update-nrf9151-fw/#overview","title":"Overview","text":"<p>This guide describes how you can update the application firmware and modem firmware of the nRF9151 SiP on the nRF9151 Connect Kit through the Interface MCU.</p>"},{"location":"guides/programming/update-nrf9151-fw/#requirements","title":"Requirements","text":"<p>Before you start, check that you have the required hardware and software:</p> <ul> <li>1x nRF9151 Connect Kit</li> <li>1x USB-C Cable</li> <li>Python 3.10.0 or newer</li> <li>pyOCD v0.36.0 or newer</li> <li>A computer running macOS, Ubuntu, or Windows 10 or newer</li> </ul> <p>Tip</p> <p>Python and pyOCD will be installed automatically after setting up your development environment in Getting Started Guide.</p>"},{"location":"guides/programming/update-nrf9151-fw/#installing-pyocd","title":"Installing pyOCD","text":"<p>To program the nRF9151 SiP, a tool that supports the CMSIS-DAP protocol should be installed. pyOCD v0.36.0 or newer is highly recommended.</p> <p>The latest stable version of pyOCD may be installed via pip. Open up a terminal and run:</p> WindowsmacOSUbuntu <pre><code>py -3 -m pip install -U pyocd\n</code></pre> <pre><code>python3 -m pip install -U pyocd\n</code></pre> <pre><code>python3 -m pip install -U pyocd\n</code></pre>"},{"location":"guides/programming/update-nrf9151-fw/#connecting-the-board","title":"Connecting the board","text":"<p>Connect the nRF9151 Connect Kit to your computer with a USB-C cable.</p> <p></p> <p>Enter the following command to list the connected device:</p> <pre><code>pyocd list\n</code></pre> <p>You should see the output, similar to what is shown in the following:</p> Terminal<pre><code>#   Probe/Board              Unique ID               Target\n----------------------------------------------------------------\n0   ZEPHYR IFMCU CMSIS-DAP   820D9A5F0E38432F280DB   \u2714\ufe0e nrf91\n    Makerdiary               nRF9151 Connect Kit\n</code></pre>"},{"location":"guides/programming/update-nrf9151-fw/#updating-the-application-firmware","title":"Updating the application firmware","text":"<p>To update the nRF9151 appication firmware using pyOCD, complete the following steps:</p> <ol> <li> <p>Enter the following command to program the application firmware to the nRF9151 application core:</p> <pre><code>pyocd load -t nrf91 &lt;application.hex&gt; # (1)!\n</code></pre> <ol> <li>You can also use <code>pyocd flash</code> instead:     <pre><code>pyocd flash -t nrf91 &lt;application.hex&gt;\n</code></pre></li> </ol> </li> <li> <p>The RGB LED blinks blue rapidly during programming.</p> </li> <li>The application starts running after the firmware programming is completed. If not, press the DFU/RST button to reset the nRF9151 SiP.</li> </ol>"},{"location":"guides/programming/update-nrf9151-fw/#updating-the-modem-firmware","title":"Updating the modem firmware","text":"<p>The nRF9151 Connect Kit comes pre-programmed with the modem firmware mfw_nrf91x1_2.0.2.zip. To ensure optimal performance, you can update the modem firmware to the latest version.</p> <p>Follow these steps to update the modem firmware:</p> <ol> <li>Download the latest modem firmware from the Nordic Semiconductor official website.</li> <li>Open a terminal window.</li> <li>Change to the directory where the new modem firmware is located.</li> <li> <p>Enter the following command to program the new modem firmware on the nRF9151 SiP:</p> <pre><code>pyocd cmd -t nrf91 -c 'nrf91-update-modem-fw -f mfw_nrf91x1_2.0.2.zip'\n</code></pre> <p>If <code>-f</code> is specified, the modem firmware is written to the device, even if the correct version is already present.</p> </li> <li> <p>The RGB LED blinks blue rapidly during programming.</p> </li> <li> <p>To verify the modem firmware version, you can program a sample with AT commands, for example, AT Client, and then run the following command:</p> <pre><code>AT+CGMR # (1)!\n</code></pre> <ol> <li>This command retrieves the modem firmware revision identification.     Terminal<pre><code>mfw_nrf91x1_2.0.2\nOK\n</code></pre></li> </ol> </li> </ol>"}]}